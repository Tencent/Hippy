{"version":3,"file":"BottomUpProfileDataGrid.js","sourceRoot":"","sources":["../../../../../../front_end/panels/profiler/BottomUpProfileDataGrid.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,4DAA4D;AAC5D,+GAA+G;AAC/G,2GAA2G;AAC3G,2GAA2G;AAC3G,4DAA4D;AAE5D,uDAAuD;AAEvD,OAAO,KAAK,QAAQ,MAAM,iCAAiC,CAAC;AAK5D,OAAO,EAAC,mBAAmB,EAAE,mBAAmB,EAAC,MAAM,sBAAsB,CAAC;AAS9E,MAAM,OAAO,2BAA4B,SAAQ,mBAAmB;IAClE,mBAAmB,CAAuB;IAE1C,YAAY,WAA6C,EAAE,UAAsC;QAC/F,KAAK,CAAC,WAAW,EAAE,UAAU,EAAE,WAAW,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;QAClG,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;IAChC,CAAC;IAED,MAAM,CAAC,eAAe,CAAC,SAAkE;QACvF,IAAI,SAAS,CAAC,mBAAmB,KAAK,SAAS,EAAE;YAC/C,OAAO;SACR;QACD,MAAM,kBAAkB,GAAG,SAAS,CAAC,mBAAmB,CAAC;QACzD,MAAM,KAAK,GAAG,kBAAkB,CAAC,MAAM,CAAC;QAExC,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,EAAE,EAAE,KAAK,EAAE;YAC1C,MAAM,QAAQ,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAC3C,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;YACnC,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;YACrC,IAAI,KAAK,GACJ,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAwC,CAAC;YAE1E,+DAA+D;YAC/D,IAAI,KAAK,EAAE;gBACT,MAAM,iBAAiB,GAAG,QAAQ,CAAC,iBAAiB,CAAC;gBAErD,KAAK,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC;gBAE7B,IAAI,CAAC,iBAAiB,EAAE;oBACtB,KAAK,CAAC,KAAK,IAAI,SAAS,CAAC,KAAK,CAAC;iBAChC;aACF;iBAAM;gBACL,KAAK,GAAG,IAAI,2BAA2B,CAAC,QAAQ,EAAG,SAAS,CAAC,IAAmC,CAAC,CAAC;gBAElG,IAAI,QAAQ,KAAK,SAAS,EAAE;oBAC1B,4EAA4E;oBAC5E,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;oBAC5B,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;iBAC/B;gBAED,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aAC9B;YAED,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC/B,IAAI,MAAM,IAAI,MAAM,CAAC,MAAM,EAAE;gBAC3B,QAAQ,CAAC,QAAQ,GAAG,MAAM,CAAC;gBAC3B,IAAI,CAAC,KAAK,CAAC,mBAAmB,EAAE;oBAC9B,KAAK,CAAC,mBAAmB,GAAG,EAAE,CAAC;iBAChC;gBACD,KAAK,CAAC,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aAC1C;SACF;QAED,OAAO,SAAS,CAAC,mBAAmB,CAAC;IACvC,CAAC;IAED,sCAAsC,CAAC,mBAAwC;QAC7E,IAAI,CAAC,IAAI,EAAE,CAAC;QACZ,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC;QACrC,IAAI,CAAC,KAAK,GAAG,mBAAmB,CAAC,KAAK,CAAC;IACzC,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,KAA0B;QACvC,IAAI,CAAC,IAAI,EAAE,CAAC;QAEZ,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAED,QAAQ,CAAC,QAAgB;QACvB,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC5B,IAAI,CAAC,QAAQ,EAAE,CAAC;SACjB;QAED,IAAI,CAAC,IAAI,EAAE,CAAC;QAEZ,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QAEjC,OAAO,KAAK,EAAE,EAAE;YACb,QAAQ,CAAC,KAAK,CAAiC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SACrE;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI,KAAK,EAAE;YACT,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;SACzB;IACH,CAAC;IAED,OAAO;QACL,KAAK,CAAC,OAAO,EAAE,CAAC;QAEhB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YACzB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;SAC/D;IACH,CAAC;IAED,KAAK,CAAC,KAA0B,EAAE,YAAqB;QACrD,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC;QACxB,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;IACnC,CAAC;IAED,gBAAgB;QACd,2BAA2B,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACpD,CAAC;IAED,iBAAiB,CAAC,WAA6C;QAC7D,qFAAqF;QACrF,4EAA4E;QAC5E,OAAO,OAAO,CAAC,WAAW,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAClE,CAAC;CACF;AAED,MAAM,OAAO,2BAA4B,SAAQ,mBAAmB;IAClE,UAAU,CAAU;IACpB,mBAAmB,CAAuB;IAE1C,YACI,SAAoB,EAAE,cAAgD,EACtE,eAAiD,EAAE,KAAa;QAClE,KAAK,CAAC,SAAS,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;QACxC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAExB,kCAAkC;QAClC,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,MAAM,iBAAiB,GAAG,CAAC,EAAE,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;QAClD,MAAM,6BAA6B,GAAG,IAAI,GAAG,EAAuB,CAAC;QAErE,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAE9B,KAAK,IAAI,qBAAqB,GAAG,CAAC,EAAE,qBAAqB,GAAG,iBAAiB,CAAC,MAAM,EAAE,EAAE,qBAAqB,EAAE;YAC7G,MAAM,kBAAkB,GAAG,iBAAiB,CAAC,qBAAqB,CAAC,CAAC;YACpE,MAAM,YAAY,GAAG,iBAAiB,CAAC,EAAE,qBAAqB,CAAC,CAAC;YAChE,MAAM,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC;YAElC,MAAM,oBAAoB,GAAG,IAAI,OAAO,EAA4C,CAAC;YAErF,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,EAAE,EAAE,KAAK,EAAE;gBAC1C,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;gBAExC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;oBAC1C,oBAAoB,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,eAAe,CAAC,CAAC;iBAC1D;gBAED,IAAI,WAAW,CAAC,MAAM,EAAE;oBACtB,4FAA4F;oBAC5F,IAAI,YAAY,GAAG,6BAA6B,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;oBAC1E,IAAI,iBAAiB,GAAG,KAAK,CAAC;oBAE9B,IAAI,CAAC,YAAY,EAAE;wBACjB,YAAY,GAAG,IAAI,GAAG,EAAE,CAAC;wBACzB,6BAA6B,CAAC,GAAG,CAAC,WAAW,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;qBACtE;yBAAM;wBACL,gHAAgH;wBAChH,sFAAsF;wBACtF,MAAM,WAAW,GAAG,kBAAkB,CAAC,MAAM,CAAC;wBAC9C,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,WAAW,EAAE,EAAE,WAAW,EAAE;4BAClE,MAAM,SAAS,GAAG,oBAAoB,CAAC,GAAG,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC;4BAC5E,IAAI,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gCAC5C,iBAAiB,GAAG,IAAI,CAAC;gCACzB,MAAM;6BACP;yBACF;qBACF;oBAED,MAAM,GAAG,GAAG,oBAAoB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;oBAClD,IAAI,GAAG,EAAE;wBACP,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;qBACvB;oBAED,IAAI,CAAC,mBAAmB,CAAC,IAAI,CACzB,EAAC,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,WAAW,EAAE,iBAAiB,EAAE,iBAAiB,EAAC,CAAC,CAAC;iBAC5F;gBAED,MAAM,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC;gBACtC,IAAI,QAAQ,CAAC,MAAM,EAAE;oBACnB,iBAAiB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjE,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;iBAClC;aACF;SACF;QAED,gCAAgC;QAChC,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEnC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,mBAAwC;QAC5C,IAAI,CAAC,mBAAmB,EAAE;YACxB,OAAO;SACR;QAED,IAAI,CAAC,IAAI,EAAE,CAAC;QAEZ,IAAI,WAAW,GAAwB,mBAAmB,CAAC;QAC3D,IAAI,SAAS,GAA0E,mBAAmB,CAAC;QAE3G,OAAO,WAAW,CAAC,MAAM,IAAI,CAAC,WAAW,YAAY,2BAA2B,CAAC,EAAE;YACjF,WAAW,CAAC,sCAAsC,CAAC,mBAAmB,CAAC,CAAC;YAExE,SAAS,GAAG,WAAW,CAAC;YACxB,WAAW,GAAI,WAAW,CAAC,MAA8B,CAAC;YAE1D,IAAI,WAAW,YAAY,2BAA2B,EAAE;gBACtD,WAAW,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;aACvC;SACF;QAED,IAAI,CAAC,QAAQ,GAAG,CAAC,SAAS,CAAC,CAAC;QAC5B,IAAI,CAAC,KAAK,GAAG,mBAAmB,CAAC,KAAK,CAAC;IACzC,CAAC;IAED,OAAO,CAAC,mBAAwC;QAC9C,IAAI,CAAC,mBAAmB,EAAE;YACxB,OAAO;SACR;QAED,IAAI,CAAC,IAAI,EAAE,CAAC;QAEZ,MAAM,eAAe,GAAG,mBAAmB,CAAC,OAAO,CAAC;QACpD,MAAM,qBAAqB,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QAE1E,iGAAiG;QACjG,yDAAyD;QACzD,IAAI,qBAAqB,EAAE;YACzB,QAAQ,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,qBAAqB,CAAC,CAAC;SAC7E;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC;QAE9B,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,EAAE,EAAE,KAAK,EAAE;YACzC,QAAQ,CAAC,KAAK,CAAiC,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;SAC5E;QAED,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;SACtC;IACH,CAAC;IAED,gBAAgB;QACd,2BAA2B,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACpD,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2009 280 North Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// Bottom Up Profiling shows the entire callstack backwards:\n// The root node is a representation of each individual function called, and each child of that node represents\n// a reverse-callstack showing how many of those calls came from it. So, unlike top-down, the statistics in\n// each child still represent the root node. We have to be particularly careful of recursion with this mode\n// because a root node can represent itself AND an ancestor.\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as UI from '../../ui/legacy/legacy.js';\n\nimport type {Formatter} from './ProfileDataGrid.js';\nimport {ProfileDataGridNode, ProfileDataGridTree} from './ProfileDataGrid.js';\nimport type {TopDownProfileDataGridTree} from './TopDownProfileDataGrid.js';\n\nexport interface NodeInfo {\n  ancestor: SDK.ProfileTreeModel.ProfileNode;\n  focusNode: SDK.ProfileTreeModel.ProfileNode;\n  totalAccountedFor: boolean;\n}\n\nexport class BottomUpProfileDataGridNode extends ProfileDataGridNode {\n  _remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(profileNode: SDK.ProfileTreeModel.ProfileNode, owningTree: TopDownProfileDataGridTree) {\n    super(profileNode, owningTree, profileNode.parent !== null && Boolean(profileNode.parent.parent));\n    this._remainingNodeInfos = [];\n  }\n\n  static _sharedPopulate(container: BottomUpProfileDataGridNode|BottomUpProfileDataGridTree): void {\n    if (container._remainingNodeInfos === undefined) {\n      return;\n    }\n    const remainingNodeInfos = container._remainingNodeInfos;\n    const count = remainingNodeInfos.length;\n\n    for (let index = 0; index < count; ++index) {\n      const nodeInfo = remainingNodeInfos[index];\n      const ancestor = nodeInfo.ancestor;\n      const focusNode = nodeInfo.focusNode;\n      let child: BottomUpProfileDataGridNode|(BottomUpProfileDataGridNode | null) =\n          (container.findChild(ancestor) as BottomUpProfileDataGridNode | null);\n\n      // If we already have this child, then merge the data together.\n      if (child) {\n        const totalAccountedFor = nodeInfo.totalAccountedFor;\n\n        child.self += focusNode.self;\n\n        if (!totalAccountedFor) {\n          child.total += focusNode.total;\n        }\n      } else {\n        child = new BottomUpProfileDataGridNode(ancestor, (container.tree as TopDownProfileDataGridTree));\n\n        if (ancestor !== focusNode) {\n          // But the actual statistics from the \"root\" node (bottom of the callstack).\n          child.self = focusNode.self;\n          child.total = focusNode.total;\n        }\n\n        container.appendChild(child);\n      }\n\n      const parent = ancestor.parent;\n      if (parent && parent.parent) {\n        nodeInfo.ancestor = parent;\n        if (!child._remainingNodeInfos) {\n          child._remainingNodeInfos = [];\n        }\n        child._remainingNodeInfos.push(nodeInfo);\n      }\n    }\n\n    delete container._remainingNodeInfos;\n  }\n\n  _takePropertiesFromProfileDataGridNode(profileDataGridNode: ProfileDataGridNode): void {\n    this.save();\n    this.self = profileDataGridNode.self;\n    this.total = profileDataGridNode.total;\n  }\n\n  /**\n   * When focusing, we keep just the members of the callstack.\n   */\n  _keepOnlyChild(child: ProfileDataGridNode): void {\n    this.save();\n\n    this.removeChildren();\n    this.appendChild(child);\n  }\n\n  _exclude(aCallUID: string): void {\n    if (this._remainingNodeInfos) {\n      this.populate();\n    }\n\n    this.save();\n\n    const children = this.children;\n    let index = this.children.length;\n\n    while (index--) {\n      (children[index] as BottomUpProfileDataGridNode)._exclude(aCallUID);\n    }\n\n    const child = this.childrenByCallUID.get(aCallUID);\n\n    if (child) {\n      this.merge(child, true);\n    }\n  }\n\n  restore(): void {\n    super.restore();\n\n    if (!this.children.length) {\n      this.setHasChildren(this._willHaveChildren(this.profileNode));\n    }\n  }\n\n  merge(child: ProfileDataGridNode, shouldAbsorb: boolean): void {\n    this.self -= child.self;\n    super.merge(child, shouldAbsorb);\n  }\n\n  populateChildren(): void {\n    BottomUpProfileDataGridNode._sharedPopulate(this);\n  }\n\n  _willHaveChildren(profileNode: SDK.ProfileTreeModel.ProfileNode): boolean {\n    // In bottom up mode, our parents are our children since we display an inverted tree.\n    // However, we don't want to show the very top parent since it is redundant.\n    return Boolean(profileNode.parent && profileNode.parent.parent);\n  }\n}\n\nexport class BottomUpProfileDataGridTree extends ProfileDataGridTree {\n  deepSearch: boolean;\n  _remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(\n      formatter: Formatter, searchableView: UI.SearchableView.SearchableView,\n      rootProfileNode: SDK.ProfileTreeModel.ProfileNode, total: number) {\n    super(formatter, searchableView, total);\n    this.deepSearch = false;\n\n    // Iterate each node in pre-order.\n    let profileNodeUIDs = 0;\n    const profileNodeGroups = [[], [rootProfileNode]];\n    const visitedProfileNodesForCallUID = new Map<string, Set<number>>();\n\n    this._remainingNodeInfos = [];\n\n    for (let profileNodeGroupIndex = 0; profileNodeGroupIndex < profileNodeGroups.length; ++profileNodeGroupIndex) {\n      const parentProfileNodes = profileNodeGroups[profileNodeGroupIndex];\n      const profileNodes = profileNodeGroups[++profileNodeGroupIndex];\n      const count = profileNodes.length;\n\n      const profileNodeUIDValues = new WeakMap<SDK.ProfileTreeModel.ProfileNode, number>();\n\n      for (let index = 0; index < count; ++index) {\n        const profileNode = profileNodes[index];\n\n        if (!profileNodeUIDValues.get(profileNode)) {\n          profileNodeUIDValues.set(profileNode, ++profileNodeUIDs);\n        }\n\n        if (profileNode.parent) {\n          // The total time of this ancestor is accounted for if we're in any form of recursive cycle.\n          let visitedNodes = visitedProfileNodesForCallUID.get(profileNode.callUID);\n          let totalAccountedFor = false;\n\n          if (!visitedNodes) {\n            visitedNodes = new Set();\n            visitedProfileNodesForCallUID.set(profileNode.callUID, visitedNodes);\n          } else {\n            // The total time for this node has already been accounted for iff one of it's parents has already been visited.\n            // We can do this check in this style because we are traversing the tree in pre-order.\n            const parentCount = parentProfileNodes.length;\n            for (let parentIndex = 0; parentIndex < parentCount; ++parentIndex) {\n              const parentUID = profileNodeUIDValues.get(parentProfileNodes[parentIndex]);\n              if (parentUID && visitedNodes.has(parentUID)) {\n                totalAccountedFor = true;\n                break;\n              }\n            }\n          }\n\n          const uid = profileNodeUIDValues.get(profileNode);\n          if (uid) {\n            visitedNodes.add(uid);\n          }\n\n          this._remainingNodeInfos.push(\n              {ancestor: profileNode, focusNode: profileNode, totalAccountedFor: totalAccountedFor});\n        }\n\n        const children = profileNode.children;\n        if (children.length) {\n          profileNodeGroups.push(parentProfileNodes.concat([profileNode]));\n          profileNodeGroups.push(children);\n        }\n      }\n    }\n\n    // Populate the top level nodes.\n    ProfileDataGridNode.populate(this);\n\n    return this;\n  }\n\n  /**\n   * When focusing, we keep the entire callstack up to this ancestor.\n   */\n  focus(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    let currentNode: ProfileDataGridNode = profileDataGridNode;\n    let focusNode: (ProfileDataGridNode&BottomUpProfileDataGridNode)|ProfileDataGridNode = profileDataGridNode;\n\n    while (currentNode.parent && (currentNode instanceof BottomUpProfileDataGridNode)) {\n      currentNode._takePropertiesFromProfileDataGridNode(profileDataGridNode);\n\n      focusNode = currentNode;\n      currentNode = (currentNode.parent as ProfileDataGridNode);\n\n      if (currentNode instanceof BottomUpProfileDataGridNode) {\n        currentNode._keepOnlyChild(focusNode);\n      }\n    }\n\n    this.children = [focusNode];\n    this.total = profileDataGridNode.total;\n  }\n\n  exclude(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    const excludedCallUID = profileDataGridNode.callUID;\n    const excludedTopLevelChild = this.childrenByCallUID.get(excludedCallUID);\n\n    // If we have a top level node that is excluded, get rid of it completely (not keeping children),\n    // since bottom up data relies entirely on the root node.\n    if (excludedTopLevelChild) {\n      Platform.ArrayUtilities.removeElement(this.children, excludedTopLevelChild);\n    }\n\n    const children = this.children;\n    const count = children.length;\n\n    for (let index = 0; index < count; ++index) {\n      (children[index] as BottomUpProfileDataGridNode)._exclude(excludedCallUID);\n    }\n\n    if (this.lastComparator) {\n      this.sort(this.lastComparator, true);\n    }\n  }\n\n  populateChildren(): void {\n    BottomUpProfileDataGridNode._sharedPopulate(this);\n  }\n}\n"]}