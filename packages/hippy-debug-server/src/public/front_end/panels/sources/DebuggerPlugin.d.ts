import * as Common from '../../core/common/common.js';
import * as SDK from '../../core/sdk/sdk.js';
import * as Bindings from '../../models/bindings/bindings.js';
import * as Workspace from '../../models/workspace/workspace.js';
import * as SourceFrame from '../../ui/legacy/components/source_frame/source_frame.js';
import type * as TextEditor from '../../ui/legacy/components/text_editor/text_editor.js';
import * as UI from '../../ui/legacy/legacy.js';
import { Plugin } from './Plugin.js';
import { SourcesPanel } from './SourcesPanel.js';
declare class DecoratorWidget extends HTMLDivElement {
    __nameToToken: Map<string, HTMLElement>;
    constructor();
}
export declare class DebuggerPlugin extends Plugin {
    _textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor;
    _uiSourceCode: Workspace.UISourceCode.UISourceCode;
    _transformer: SourceFrame.SourceFrame.Transformer;
    _executionLocation: Workspace.UISourceCode.UILocation | null;
    _controlDown: boolean;
    _asyncStepInHoveredLine: number | null;
    _asyncStepInHovered: boolean;
    _clearValueWidgetsTimer: number | null;
    _sourceMapInfobar: UI.Infobar.Infobar | null;
    _controlTimeout: number | null;
    _scriptsPanel: SourcesPanel;
    _breakpointManager: Bindings.BreakpointManager.BreakpointManager;
    _popoverHelper: UI.PopoverHelper.PopoverHelper;
    _boundPopoverHelperHide: () => void;
    _boundKeyDown: (arg0: Event) => void;
    _boundKeyUp: (arg0: Event) => void;
    _boundMouseMove: (arg0: Event) => void;
    _boundMouseDown: (arg0: Event) => void;
    _boundBlur: (arg0: Event) => void;
    _boundWheel: (arg0: Event) => void;
    _boundGutterClick: (arg0: Common.EventTarget.EventTargetEvent) => void;
    _breakpointDecorations: Set<BreakpointDecoration>;
    _decorationByBreakpoint: Map<Bindings.BreakpointManager.Breakpoint, BreakpointDecoration>;
    _possibleBreakpointsRequested: Set<number>;
    _scriptFileForDebuggerModel: Map<SDK.DebuggerModel.DebuggerModel, Bindings.ResourceScriptMapping.ResourceScriptFile>;
    _valueWidgets: Map<number, DecoratorWidget>;
    _continueToLocationDecorations: Map<any, Function> | null;
    _liveLocationPool: Bindings.LiveLocation.LiveLocationPool;
    _muted: boolean;
    _mutedFromStart: boolean;
    _ignoreListInfobar: UI.Infobar.Infobar | null;
    _hasLineWithoutMapping: boolean;
    _prettyPrintInfobar: UI.Infobar.Infobar | null;
    _scheduledBreakpointDecorationUpdates?: Set<BreakpointDecoration> | null;
    constructor(textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor, uiSourceCode: Workspace.UISourceCode.UISourceCode, transformer: SourceFrame.SourceFrame.Transformer);
    static accepts(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean;
    _showIgnoreListInfobarIfNeeded(): void;
    _hideIgnoreListInfobar(): void;
    wasShown(): void;
    willHide(): void;
    populateLineGutterContextMenu(contextMenu: UI.ContextMenu.ContextMenu, editorLineNumber: number): Promise<void>;
    populateTextAreaContextMenu(contextMenu: UI.ContextMenu.ContextMenu, editorLineNumber: number, editorColumnNumber: number): Promise<void>;
    _workingCopyChanged(): void;
    _workingCopyCommitted(_event: Common.EventTarget.EventTargetEvent): void;
    _didMergeToVM(): void;
    _didDivergeFromVM(): void;
    _muteBreakpointsWhileEditing(): void;
    _restoreBreakpointsIfConsistentScripts(): Promise<void>;
    _restoreBreakpointsAfterEditing(): Promise<void>;
    _isIdentifier(tokenType: string): boolean;
    _getPopoverRequest(event: MouseEvent): UI.PopoverHelper.PopoverRequest | null;
    _onWheel(event: WheelEvent): void;
    _onKeyDown(event: KeyboardEvent): void;
    _onMouseMove(event: MouseEvent): void;
    _setAsyncStepInHoveredLine(editorLineNumber: number | null, hovered: boolean): void;
    _onMouseDown(event: MouseEvent): void;
    _onBlur(_event: Event): void;
    _onKeyUp(_event: KeyboardEvent): void;
    _clearControlDown(): void;
    _editBreakpointCondition(editorLineNumber: number, breakpoint: Bindings.BreakpointManager.Breakpoint | null, location: {
        lineNumber: number;
        columnNumber: number;
    } | null, preferLogpoint?: boolean): Promise<void>;
    _executionLineChanged(liveLocation: Bindings.LiveLocation.LiveLocation): Promise<void>;
    _generateValuesInSource(): void;
    _showContinueToLocations(): void;
    _continueToLocationRenderedForTest(): void;
    _findAsyncStepInRange(textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor, editorLineNumber: number, line: string, column: number): {
        from: number;
        to: number;
    } | null;
    _asyncStepIn(location: SDK.DebuggerModel.BreakLocation, isCurrentPosition: boolean): void;
    _prepareScopeVariables(callFrame: SDK.DebuggerModel.CallFrame, allProperties: SDK.RemoteObject.GetPropertiesResult): Promise<void>;
    _renderDecorations(valuesMap: Map<string, SDK.RemoteObject.RemoteObject>, namesPerLine: Map<number, Set<string>>, fromLine: number, toLine: number): void;
    _clearExecutionLine(): void;
    _clearValueWidgets(): void;
    _clearContinueToLocationsNoRestore(): void;
    _clearContinueToLocations(): void;
    _lineBreakpointDecorations(lineNumber: number): BreakpointDecoration[];
    _breakpointDecoration(editorLineNumber: number, editorColumnNumber: number): BreakpointDecoration | null;
    _updateBreakpointDecoration(decoration: BreakpointDecoration): void;
    _breakpointDecorationsUpdatedForTest(): void;
    _inlineBreakpointClick(decoration: BreakpointDecoration, event: MouseEvent): Promise<void>;
    _inlineBreakpointContextMenu(decoration: BreakpointDecoration, event: Event): void;
    _shouldIgnoreExternalBreakpointEvents(event: Common.EventTarget.EventTargetEvent): boolean;
    _breakpointAdded(event: Common.EventTarget.EventTargetEvent): void;
    _addBreakpoint(uiLocation: Workspace.UISourceCode.UILocation, breakpoint: Bindings.BreakpointManager.Breakpoint): void;
    _breakpointRemoved(event: Common.EventTarget.EventTargetEvent): void;
    _initializeBreakpoints(): void;
    _updateLinesWithoutMappingHighlight(): void;
    _updateScriptFiles(): void;
    _updateScriptFile(debuggerModel: SDK.DebuggerModel.DebuggerModel): void;
    _showSourceMapInfobar(): void;
    _detectMinified(): Promise<void>;
    _handleGutterClick(event: Common.EventTarget.EventTargetEvent): Promise<void>;
    _toggleBreakpoint(editorLineNumber: number, onlyDisable: boolean): Promise<void>;
    _createNewBreakpoint(editorLineNumber: number, condition: string, enabled: boolean): Promise<void>;
    _setBreakpoint(lineNumber: number, columnNumber: number | undefined, condition: string, enabled: boolean): Promise<void>;
    _breakpointWasSetForTest(_lineNumber: number, _columnNumber: number | undefined, _condition: string, _enabled: boolean): void;
    _callFrameChanged(): Promise<void>;
    dispose(): void;
}
export declare class BreakpointDecoration {
    _textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor;
    handle: TextEditor.CodeMirrorTextEditor.TextEditorPositionHandle;
    condition: string;
    enabled: boolean;
    bound: boolean;
    breakpoint: Bindings.BreakpointManager.Breakpoint | null;
    element: HTMLSpanElement;
    bookmark: TextEditor.CodeMirrorTextEditor.TextEditorBookMark | null;
    constructor(textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor, handle: TextEditor.CodeMirrorTextEditor.TextEditorPositionHandle, condition: string, enabled: boolean, bound: boolean, breakpoint: Bindings.BreakpointManager.Breakpoint | null);
    static mostSpecificFirst(decoration1: BreakpointDecoration, decoration2: BreakpointDecoration): number;
    update(): void;
    show(): void;
    hide(): void;
    dispose(): void;
    static readonly bookmarkSymbol: unique symbol;
    static readonly _elementSymbolForTest: unique symbol;
}
export declare const continueToLocationDecorationSymbol: unique symbol;
export {};
