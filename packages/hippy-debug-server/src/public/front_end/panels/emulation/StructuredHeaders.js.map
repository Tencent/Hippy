{"version":3,"file":"StructuredHeaders.js","sourceRoot":"","sources":["../../../../../../front_end/panels/emulation/StructuredHeaders.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// This provides parsing and serialization for HTTP structured headers as specified in:\n// https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19\n// (the ABNF fragments are quoted from the spec, unless otherwise specified,\n//  and the code pretty much just follows the algorithms given there).\n//\n// parseList, parseItem, serializeList, and serializeItem are the main entry points.\n//\n// Currently dictionary handling is not implemented (but would likely be easy\n// to add).  Serialization of decimals and byte sequences is also not\n// implemented.\n\nexport const enum ResultKind {\n  ERROR = 0,\n  PARAM_NAME = 1,\n  PARAMETER = 2,\n  PARAMETERS = 3,\n  ITEM = 4,\n  INTEGER = 5,\n  DECIMAL = 6,\n  STRING = 7,\n  TOKEN = 8,\n  BINARY = 9,\n  BOOLEAN = 10,\n  LIST = 11,\n  INNER_LIST = 12,\n  SERIALIZATION_RESULT = 13,\n}\n\nexport interface Error {\n  kind: ResultKind.ERROR;\n}\n\nexport interface Integer {\n  kind: ResultKind.INTEGER;\n  value: number;\n}\n\nexport interface Decimal {\n  kind: ResultKind.DECIMAL;\n  value: number;\n}\n\nexport interface String {\n  kind: ResultKind.STRING;\n  value: string;\n}\n\nexport interface Token {\n  kind: ResultKind.TOKEN;\n  value: string;\n}\n\nexport interface Binary {\n  kind: ResultKind.BINARY;\n  // This is undecoded base64\n  value: string;\n}\n\nexport interface Boolean {\n  kind: ResultKind.BOOLEAN;\n  value: boolean;\n}\n\n//  bare-item = sf-integer / sf-decimal / sf-string / sf-token\n//              / sf-binary / sf-boolean\nexport type BareItem = Integer|Decimal|String|Token|Binary|Boolean;\n\nexport interface ParamName {\n  kind: ResultKind.PARAM_NAME;\n  value: string;\n}\n\n// parameter     = param-name [ \"=\" param-value ]\n// param-value   = bare-item\nexport interface Parameter {\n  kind: ResultKind.PARAMETER;\n  name: ParamName;\n  value: BareItem;\n}\n\n// parameters  = *( \";\" *SP parameter )\nexport interface Parameters {\n  kind: ResultKind.PARAMETERS;\n  items: Parameter[];\n}\n\n// sf-item   = bare-item parameters\nexport interface Item {\n  kind: ResultKind.ITEM;\n  value: BareItem;\n  parameters: Parameters;\n}\n\n// inner-list    = \"(\" *SP [ sf-item *( 1*SP sf-item ) *SP ] \")\"\n//                   parameters\nexport interface InnerList {\n  kind: ResultKind.INNER_LIST;\n  items: Item[];\n  parameters: Parameters;\n}\n\n// list-member = sf-item / inner-list\nexport type ListMember = Item|InnerList;\n\n// sf-list = list-member *( OWS \",\" OWS list-member )\nexport interface List {\n  kind: ResultKind.LIST;\n  items: ListMember[];\n}\n\nexport interface SerializationResult {\n  kind: ResultKind.SERIALIZATION_RESULT;\n  value: string;\n}\n\nconst CHAR_MINUS: number = '-'.charCodeAt(0);\nconst CHAR_0: number = '0'.charCodeAt(0);\nconst CHAR_9: number = '9'.charCodeAt(0);\nconst CHAR_A: number = 'A'.charCodeAt(0);\nconst CHAR_Z: number = 'Z'.charCodeAt(0);\nconst CHAR_LOWER_A: number = 'a'.charCodeAt(0);\nconst CHAR_LOWER_Z: number = 'z'.charCodeAt(0);\nconst CHAR_DQUOTE: number = '\"'.charCodeAt(0);\nconst CHAR_COLON: number = ':'.charCodeAt(0);\nconst CHAR_QUESTION_MARK: number = '?'.charCodeAt(0);\nconst CHAR_STAR: number = '*'.charCodeAt(0);\nconst CHAR_UNDERSCORE: number = '_'.charCodeAt(0);\nconst CHAR_DOT: number = '.'.charCodeAt(0);\nconst CHAR_BACKSLASH: number = '\\\\'.charCodeAt(0);\nconst CHAR_SLASH: number = '/'.charCodeAt(0);\nconst CHAR_PLUS: number = '+'.charCodeAt(0);\nconst CHAR_EQUALS: number = '='.charCodeAt(0);\nconst CHAR_EXCLAMATION: number = '!'.charCodeAt(0);\nconst CHAR_HASH: number = '#'.charCodeAt(0);\nconst CHAR_DOLLAR: number = '$'.charCodeAt(0);\nconst CHAR_PERCENT: number = '%'.charCodeAt(0);\nconst CHAR_AND: number = '&'.charCodeAt(0);\nconst CHAR_SQUOTE: number = '\\''.charCodeAt(0);\nconst CHAR_HAT: number = '^'.charCodeAt(0);\nconst CHAR_BACKTICK: number = '`'.charCodeAt(0);\nconst CHAR_PIPE: number = '|'.charCodeAt(0);\nconst CHAR_TILDE: number = '~'.charCodeAt(0);\n\n// ASCII printable range.\nconst CHAR_MIN_ASCII_PRINTABLE: number = 0x20;\nconst CHAR_MAX_ASCII_PRINTABLE: number = 0x7e;\n\n// Note: structured headers operates over ASCII, not unicode, so these are\n// all indeed supposed to return false on things outside 32-127 range regardless\n// of them being other kinds of digits or letters.\nfunction isDigit(charCode: number|undefined): boolean {\n  // DIGIT = %x30-39 ; 0-9 (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return charCode >= CHAR_0 && charCode <= CHAR_9;\n}\n\nfunction isAlpha(charCode: number|undefined): boolean {\n  // ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_A && charCode <= CHAR_Z) || (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isLcAlpha(charCode: number|undefined): boolean {\n  // lcalpha = %x61-7A ; a-z\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isTChar(charCode: number|undefined): boolean {\n  if (charCode === undefined) {\n    return false;\n  }\n\n  // tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n  // \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA (from RFC 7230)\n  if (isDigit(charCode) || isAlpha(charCode)) {\n    return true;\n  }\n  switch (charCode) {\n    case CHAR_EXCLAMATION:\n    case CHAR_HASH:\n    case CHAR_DOLLAR:\n    case CHAR_PERCENT:\n    case CHAR_AND:\n    case CHAR_SQUOTE:\n    case CHAR_STAR:\n    case CHAR_PLUS:\n    case CHAR_MINUS:\n    case CHAR_DOT:\n    case CHAR_HAT:\n    case CHAR_UNDERSCORE:\n    case CHAR_BACKTICK:\n    case CHAR_PIPE:\n    case CHAR_TILDE:\n      return true;\n    default:\n      return false;\n  }\n}\n\nclass Input {\n  private readonly data: string;\n  private pos: number;\n\n  constructor(input: string) {\n    this.data = input;\n    this.pos = 0;\n    // 4.2 step 2 is to discard any leading SP characters.\n    this.skipSP();\n  }\n\n  peek(): string|undefined {\n    return this.data[this.pos];\n  }\n\n  peekCharCode(): number|undefined {\n    return (this.pos < this.data.length ? this.data.charCodeAt(this.pos) : undefined);\n  }\n\n  eat(): void {\n    ++this.pos;\n  }\n\n  // Matches SP*.\n  // SP = %x20, from RFC 5234\n  skipSP(): void {\n    while (this.data[this.pos] === ' ') {\n      ++this.pos;\n    }\n  }\n\n  // Matches OWS\n  // OWS = *( SP / HTAB ) , from RFC 7230\n  skipOWS(): void {\n    while (this.data[this.pos] === ' ' || this.data[this.pos] === '\\t') {\n      ++this.pos;\n    }\n  }\n\n  atEnd(): boolean {\n    return (this.pos === this.data.length);\n  }\n\n  // 4.2 steps 6,7 --- checks for trailing characters.\n  allParsed(): boolean {\n    this.skipSP();\n    return (this.pos === this.data.length);\n  }\n}\n\nfunction makeError(): Error {\n  return {kind: ResultKind.ERROR};\n}\n\n// 4.2.1. Parsing a list\nfunction parseListInternal(input: Input): List|Error {\n  const result: List = {kind: ResultKind.LIST, items: []};\n\n  while (!input.atEnd()) {\n    const piece: ListMember|Error = parseItemOrInnerList(input);\n    if (piece.kind === ResultKind.ERROR) {\n      return piece;\n    }\n    result.items.push(piece);\n    input.skipOWS();\n    if (input.atEnd()) {\n      return result;\n    }\n\n    if (input.peek() !== ',') {\n      return makeError();\n    }\n    input.eat();\n    input.skipOWS();\n\n    // \"If input_string is empty, there is a trailing comma; fail parsing.\"\n    if (input.atEnd()) {\n      return makeError();\n    }\n  }\n  return result;  // this case corresponds to an empty list.\n}\n\n// 4.2.1.1.  Parsing an Item or Inner List\nfunction parseItemOrInnerList(input: Input): ListMember|Error {\n  if (input.peek() === '(') {\n    return parseInnerList(input);\n  }\n  return parseItemInternal(input);\n}\n\n// 4.2.1.2.  Parsing an Inner List\nfunction parseInnerList(input: Input): InnerList|Error {\n  if (input.peek() !== '(') {\n    return makeError();\n  }\n  input.eat();\n\n  const items: Item[] = [];\n  while (!input.atEnd()) {\n    input.skipSP();\n    if (input.peek() === ')') {\n      input.eat();\n      const params: Parameters|Error = parseParameters(input);\n      if (params.kind === ResultKind.ERROR) {\n        return params;\n      }\n      return {\n        kind: ResultKind.INNER_LIST,\n        items: items,\n        parameters: params,\n      };\n    }\n    const item: Item|Error = parseItemInternal(input);\n    if (item.kind === ResultKind.ERROR) {\n      return item;\n    }\n    items.push(item);\n    if (input.peek() !== ' ' && input.peek() !== ')') {\n      return makeError();\n    }\n  }\n\n  // Didn't see ), so error.\n  return makeError();\n}\n\n// 4.2.3.  Parsing an Item\nfunction parseItemInternal(input: Input): Item|Error {\n  const bareItem: BareItem|Error = parseBareItem(input);\n  if (bareItem.kind === ResultKind.ERROR) {\n    return bareItem;\n  }\n  const params: Parameters|Error = parseParameters(input);\n  if (params.kind === ResultKind.ERROR) {\n    return params;\n  }\n  return {kind: ResultKind.ITEM, value: bareItem, parameters: params};\n}\n\n// 4.2.3.1.  Parsing a Bare Item\nfunction parseBareItem(input: Input): BareItem|Error {\n  const upcoming = input.peekCharCode();\n  if (upcoming === CHAR_MINUS || isDigit(upcoming)) {\n    return parseIntegerOrDecimal(input);\n  }\n  if (upcoming === CHAR_DQUOTE) {\n    return parseString(input);\n  }\n  if (upcoming === CHAR_COLON) {\n    return parseByteSequence(input);\n  }\n  if (upcoming === CHAR_QUESTION_MARK) {\n    return parseBoolean(input);\n  }\n  if (upcoming === CHAR_STAR || isAlpha(upcoming)) {\n    return parseToken(input);\n  }\n  return makeError();\n}\n\n// 4.2.3.2.  Parsing Parameters\nfunction parseParameters(input: Input): Parameters|Error {\n  // The main noteworthy thing here is handling of duplicates and ordering:\n  //\n  // \"Note that Parameters are ordered as serialized\"\n  //\n  // \"If parameters already contains a name param_name (comparing\n  // character-for-character), overwrite its value.\"\n  //\n  // \"Note that when duplicate Parameter keys are encountered, this has the\n  // effect of ignoring all but the last instance.\"\n  const items: Map<string, Parameter> = new Map<string, Parameter>();\n  while (!input.atEnd()) {\n    if (input.peek() !== ';') {\n      break;\n    }\n    input.eat();\n    input.skipSP();\n    const paramName = parseKey(input);\n    if (paramName.kind === ResultKind.ERROR) {\n      return paramName;\n    }\n\n    let paramValue: BareItem = {kind: ResultKind.BOOLEAN, value: true};\n    if (input.peek() === '=') {\n      input.eat();\n      const parsedParamValue: BareItem|Error = parseBareItem(input);\n      if (parsedParamValue.kind === ResultKind.ERROR) {\n        return parsedParamValue;\n      }\n      paramValue = parsedParamValue;\n    }\n\n    // Delete any previous occurrence of duplicates to get the ordering right.\n    if (items.has(paramName.value)) {\n      items.delete(paramName.value);\n    }\n\n    items.set(paramName.value, {kind: ResultKind.PARAMETER, name: paramName, value: paramValue});\n  }\n\n  return {kind: ResultKind.PARAMETERS, items: [...items.values()]};\n}\n\n// 4.2.3.3.  Parsing a Key\nfunction parseKey(input: Input): ParamName|Error {\n  let outputString: string = '';\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isLcAlpha(first)) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (!isLcAlpha(upcoming) && !isDigit(upcoming) && upcoming !== CHAR_UNDERSCORE && upcoming !== CHAR_MINUS &&\n        upcoming !== CHAR_DOT && upcoming !== CHAR_STAR) {\n      break;\n    }\n    outputString += input.peek();\n    input.eat();\n  }\n\n  return {kind: ResultKind.PARAM_NAME, value: outputString};\n}\n\n// 4.2.4.  Parsing an Integer or Decimal\nfunction parseIntegerOrDecimal(input: Input): Integer|Decimal|Error {\n  let resultKind = ResultKind.INTEGER;\n  let sign: number = 1;\n  let inputNumber = '';\n  if (input.peek() === '-') {\n    input.eat();\n    sign = -1;\n  }\n\n  // This case includes end of input.\n  if (!isDigit(input.peekCharCode())) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    if (char !== undefined && isDigit(char)) {\n      input.eat();\n      inputNumber += String.fromCodePoint(char);\n    } else if (char === CHAR_DOT && resultKind === ResultKind.INTEGER) {\n      input.eat();\n      if (inputNumber.length > 12) {\n        return makeError();\n      }\n      inputNumber += '.';\n      resultKind = ResultKind.DECIMAL;\n    } else {\n      break;\n    }\n    if (resultKind === ResultKind.INTEGER && inputNumber.length > 15) {\n      return makeError();\n    }\n    if (resultKind === ResultKind.DECIMAL && inputNumber.length > 16) {\n      return makeError();\n    }\n  }\n\n  if (resultKind === ResultKind.INTEGER) {\n    const num = sign * Number.parseInt(inputNumber, 10);\n    if (num < -999999999999999 || num > 999999999999999) {\n      return makeError();\n    }\n    return {kind: ResultKind.INTEGER, value: num};\n  }\n  const afterDot = inputNumber.length - 1 - inputNumber.indexOf('.');\n  if (afterDot > 3 || afterDot === 0) {\n    return makeError();\n  }\n  return {kind: ResultKind.DECIMAL, value: sign * Number.parseFloat(inputNumber)};\n}\n\n// 4.2.5.  Parsing a String\nfunction parseString(input: Input): String|Error {\n  let outputString = '';\n  if (input.peek() !== '\"') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_BACKSLASH) {\n      if (input.atEnd()) {\n        return makeError();\n      }\n      const nextChar = input.peekCharCode();\n      input.eat();\n      if (nextChar !== CHAR_BACKSLASH && nextChar !== CHAR_DQUOTE) {\n        return makeError();\n      }\n      outputString += String.fromCodePoint(nextChar);\n    } else if (char === CHAR_DQUOTE) {\n      return {kind: ResultKind.STRING, value: outputString};\n    } else if (char < CHAR_MIN_ASCII_PRINTABLE || char > CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    } else {\n      outputString += String.fromCodePoint(char);\n    }\n  }\n\n  // No closing quote.\n  return makeError();\n}\n\n// 4.2.6.  Parsing a Token\nfunction parseToken(input: Input): Token|Error {\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isAlpha(first)) {\n    return makeError();\n  }\n  let outputString = '';\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (upcoming === undefined || !isTChar(upcoming) && upcoming !== CHAR_COLON && upcoming !== CHAR_SLASH) {\n      break;\n    }\n    input.eat();\n    outputString += String.fromCodePoint(upcoming);\n  }\n  return {kind: ResultKind.TOKEN, value: outputString};\n}\n\n// 4.2.7.  Parsing a Byte Sequence\nfunction parseByteSequence(input: Input): Binary|Error {\n  let outputString = '';\n  if (input.peek() !== ':') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_COLON) {\n      return {kind: ResultKind.BINARY, value: outputString};\n    }\n    if (isDigit(char) || isAlpha(char) || char === CHAR_PLUS || char === CHAR_SLASH || char === CHAR_EQUALS) {\n      outputString += String.fromCodePoint(char);\n    } else {\n      return makeError();\n    }\n  }\n\n  // No closing :\n  return makeError();\n}\n\n// 4.2.8.  Parsing a Boolean\nfunction parseBoolean(input: Input): Boolean|Error {\n  if (input.peek() !== '?') {\n    return makeError();\n  }\n  input.eat();\n  if (input.peek() === '0') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: false};\n  }\n  if (input.peek() === '1') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: true};\n  }\n  return makeError();\n}\n\nexport function parseItem(input: string): Item|Error {\n  const i = new Input(input);\n  const result: Item|Error = parseItemInternal(i);\n  if (!i.allParsed()) {\n    return makeError();\n  }\n  return result;\n}\n\nexport function parseList(input: string): List|Error {\n  // No need to look for trailing stuff here since parseListInternal does it already.\n  return parseListInternal(new Input(input));\n}\n\n// 4.1.3.  Serializing an Item\nexport function serializeItem(input: Item): SerializationResult|Error {\n  const bareItemVal = serializeBareItem(input.value);\n  if (bareItemVal.kind === ResultKind.ERROR) {\n    return bareItemVal;\n  }\n  const paramVal = serializeParameters(input.parameters);\n  if (paramVal.kind === ResultKind.ERROR) {\n    return paramVal;\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: bareItemVal.value + paramVal.value};\n}\n\n// 4.1.1.  Serializing a List\nexport function serializeList(input: List): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const item = input.items[i];\n    if (item.kind === ResultKind.INNER_LIST) {\n      const itemResult = serializeInnerList(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    } else {\n      const itemResult = serializeItem(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    }\n  }\n  const output = outputPieces.join(', ');\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.1.  Serializing an Inner List\nfunction serializeInnerList(input: InnerList): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const itemResult = serializeItem(input.items[i]);\n    if (itemResult.kind === ResultKind.ERROR) {\n      return itemResult;\n    }\n    outputPieces.push(itemResult.value);\n  }\n  let output = '(' + outputPieces.join(' ') + ')';\n  const paramResult = serializeParameters(input.parameters);\n  if (paramResult.kind === ResultKind.ERROR) {\n    return paramResult;\n  }\n  output += paramResult.value;\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.2.  Serializing Parameters\nfunction serializeParameters(input: Parameters): SerializationResult|Error {\n  let output = '';\n  for (const item of input.items) {\n    output += ';';\n    const nameResult = serializeKey(item.name);\n    if (nameResult.kind === ResultKind.ERROR) {\n      return nameResult;\n    }\n    output += nameResult.value;\n    const itemVal: BareItem = item.value;\n    if (itemVal.kind !== ResultKind.BOOLEAN || !itemVal.value) {\n      output += '=';\n      const itemValResult = serializeBareItem(itemVal);\n      if (itemValResult.kind === ResultKind.ERROR) {\n        return itemValResult;\n      }\n      output += itemValResult.value;\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.3.  Serializing a Key\nfunction serializeKey(input: ParamName): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isLcAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isLcAlpha(char) && !isDigit(char) && char !== CHAR_UNDERSCORE && char !== CHAR_MINUS && char !== CHAR_DOT &&\n        char !== CHAR_STAR) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n// 4.1.3.1.  Serializing a Bare Item\nfunction serializeBareItem(input: BareItem): SerializationResult|Error {\n  if (input.kind === ResultKind.INTEGER) {\n    return serializeInteger(input);\n  }\n  if (input.kind === ResultKind.DECIMAL) {\n    return serializeDecimal(input);\n  }\n  if (input.kind === ResultKind.STRING) {\n    return serializeString(input);\n  }\n  if (input.kind === ResultKind.TOKEN) {\n    return serializeToken(input);\n  }\n  if (input.kind === ResultKind.BOOLEAN) {\n    return serializeBoolean(input);\n  }\n  if (input.kind === ResultKind.BINARY) {\n    return serializeByteSequence(input);\n  }\n  return makeError();\n}\n\n// 4.1.4.  Serializing an Integer\nfunction serializeInteger(input: Integer): SerializationResult|Error {\n  if (input.value < -999999999999999 || input.value > 999999999999999 || !Number.isInteger(input.value)) {\n    return makeError();\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value.toString(10)};\n}\n\n// 4.1.5.  Serializing a Decimal\nfunction serializeDecimal(_input: Decimal): SerializationResult|Error {\n  throw 'Unimplemented';\n}\n\n// 4.1.6.  Serializing a String\nfunction serializeString(input: String): SerializationResult|Error {\n  // Only printable ASCII strings are supported by the spec.\n  for (let i = 0; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (char < CHAR_MIN_ASCII_PRINTABLE || char > CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    }\n  }\n  let output = '\"';\n  for (let i = 0; i < input.value.length; ++i) {\n    const charStr = input.value[i];\n    if (charStr === '\"' || charStr === '\\\\') {\n      output += '\\\\';\n    }\n    output += charStr;\n  }\n  output += '\"';\n\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.7.  Serializing a Token\nfunction serializeToken(input: Token): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isTChar(char) && char !== CHAR_COLON && char !== CHAR_SLASH) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n// 4.1.8.  Serializing a Byte Sequence\nfunction serializeByteSequence(_input: Binary): SerializationResult|Error {\n  throw 'Unimplemented';\n}\n\n// 4.1.9.  Serializing a Boolean\nfunction serializeBoolean(input: Boolean): SerializationResult|Error {\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value ? '?1' : '?0'};\n}\n"]}