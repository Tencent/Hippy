{"version":3,"file":"LighthouseProtocolService.js","sourceRoot":"","sources":["../../../../../../front_end/panels/lighthouse/LighthouseProtocolService.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\nimport type * as ReportRenderer from './LighthouseReporterTypes.js';\n\nlet lastId = 1;\n\nexport class ProtocolService extends Common.ObjectWrapper.ObjectWrapper {\n  private rawConnection?: ProtocolClient.InspectorBackend.Connection;\n  private lighthouseWorkerPromise?: Promise<Worker>;\n  private lighthouseMessageUpdateCallback?: ((arg0: string) => void);\n\n  async attach(): Promise<void> {\n    await SDK.TargetManager.TargetManager.instance().suspendAllTargets();\n    const mainTarget = SDK.TargetManager.TargetManager.instance().mainTarget();\n    if (!mainTarget) {\n      throw new Error('Unable to find main target required for LightHouse');\n    }\n    const childTargetManager = mainTarget.model(SDK.ChildTargetManager.ChildTargetManager);\n    if (!childTargetManager) {\n      throw new Error('Unable to find child target manager required for LightHouse');\n    }\n    this.rawConnection = await childTargetManager.createParallelConnection(message => {\n      if (typeof message === 'string') {\n        message = JSON.parse(message);\n      }\n      this.dispatchProtocolMessage(message);\n    });\n  }\n\n  getLocales(): readonly string[] {\n    return navigator.languages;\n  }\n\n  startLighthouse(auditURL: string, categoryIDs: string[], flags: Object): Promise<ReportRenderer.RunnerResult> {\n    return this.sendWithResponse('start', {url: auditURL, categoryIDs, flags, locales: this.getLocales()});\n  }\n\n  async detach(): Promise<void> {\n    const oldLighthouseWorker = this.lighthouseWorkerPromise;\n    const oldRawConnection = this.rawConnection;\n\n    // When detaching, make sure that we remove the old promises, before we\n    // perform any async cleanups. That way, if there is a message coming from\n    // lighthouse while we are in the process of cleaning up, we shouldn't deliver\n    // them to the backend.\n    this.lighthouseWorkerPromise = undefined;\n    this.rawConnection = undefined;\n\n    if (oldLighthouseWorker) {\n      (await oldLighthouseWorker).terminate();\n    }\n    if (oldRawConnection) {\n      await oldRawConnection.disconnect();\n    }\n    await SDK.TargetManager.TargetManager.instance().resumeAllTargets();\n  }\n\n  registerStatusCallback(callback: (arg0: string) => void): void {\n    this.lighthouseMessageUpdateCallback = callback;\n  }\n\n  private dispatchProtocolMessage(message: Object): void {\n    // A message without a sessionId is the main session of the main target (call it \"Main session\").\n    // A parallel connection and session was made that connects to the same main target (call it \"Lighthouse session\").\n    // Messages from the \"Lighthouse session\" have a sessionId.\n    // Without some care, there is a risk of sending the same events for the same main frame to Lighthouse–the backend\n    // will create events for the \"Main session\" and the \"Lighthouse session\".\n    // The workaround–only send message to Lighthouse if:\n    //   * the message has a sessionId (is not for the \"Main session\")\n    //   * the message does not have a sessionId (is for the \"Main session\"), but only for the Target domain\n    //     (to kickstart autoAttach in LH).\n    const protocolMessage = message as {\n      sessionId?: string,\n      method?: string,\n    };\n    if (protocolMessage.sessionId || (protocolMessage.method && protocolMessage.method.startsWith('Target'))) {\n      this.sendWithoutResponse('dispatchProtocolMessage', {message: JSON.stringify(message)});\n    }\n  }\n\n  private initWorker(): Promise<Worker> {\n    this.lighthouseWorkerPromise = new Promise<Worker>(resolve => {\n      const worker = new Worker(\n          new URL('../../entrypoints/lighthouse_worker/lighthouse_worker.js', import.meta.url), {type: 'module'});\n\n      worker.addEventListener('message', event => {\n        if (event.data === 'workerReady') {\n          resolve(worker);\n          return;\n        }\n\n        const lighthouseMessage = JSON.parse(event.data);\n\n        if (lighthouseMessage.method === 'statusUpdate') {\n          if (this.lighthouseMessageUpdateCallback && lighthouseMessage.params &&\n              'message' in lighthouseMessage.params) {\n            this.lighthouseMessageUpdateCallback(lighthouseMessage.params.message as string);\n          }\n        } else if (lighthouseMessage.method === 'sendProtocolMessage') {\n          if (lighthouseMessage.params && 'message' in lighthouseMessage.params) {\n            this.sendProtocolMessage(lighthouseMessage.params.message as string);\n          }\n        }\n      });\n    });\n    return this.lighthouseWorkerPromise;\n  }\n\n  private async ensureWorkerExists(): Promise<Worker> {\n    let worker: Worker;\n    if (!this.lighthouseWorkerPromise) {\n      worker = await this.initWorker();\n    } else {\n      worker = await this.lighthouseWorkerPromise;\n    }\n    return worker;\n  }\n\n  private sendProtocolMessage(message: string): void {\n    if (this.rawConnection) {\n      this.rawConnection.sendRawMessage(message);\n    }\n  }\n\n  private async sendWithoutResponse(method: string, params: {[x: string]: string|string[]|Object} = {}): Promise<void> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    worker.postMessage(JSON.stringify({id: messageId, method, params: {...params, id: messageId}}));\n  }\n\n  private async sendWithResponse(method: string, params: {[x: string]: string|string[]|Object} = {}):\n      Promise<ReportRenderer.RunnerResult> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    const messageResult = new Promise<ReportRenderer.RunnerResult>(resolve => {\n      const workerListener = (event: MessageEvent): void => {\n        const lighthouseMessage = JSON.parse(event.data);\n\n        if (lighthouseMessage.id === messageId) {\n          worker.removeEventListener('message', workerListener);\n          resolve(lighthouseMessage.result);\n        }\n      };\n      worker.addEventListener('message', workerListener);\n    });\n    worker.postMessage(JSON.stringify({id: messageId, method, params: {...params, id: messageId}}));\n\n    return messageResult;\n  }\n}\n"]}