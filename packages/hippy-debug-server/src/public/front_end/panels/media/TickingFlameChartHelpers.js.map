{"version":3,"file":"TickingFlameChartHelpers.js","sourceRoot":"","sources":["../../../../../../front_end/panels/media/TickingFlameChartHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nexport function formatMillisecondsToSeconds(ms: number, decimalPlaces: number): string {\n  const roundPower = Math.pow(10, 3 - decimalPlaces);\n  const denominatorPower = Math.pow(10, Math.max(0, decimalPlaces));\n  return `${Math.round(ms / roundPower) / denominatorPower} s`;\n}\n\n/**\n * Manage the bounding box properties for the ticking flame chart.\n * kept in a separate file for unit testing.\n */\nexport class Bounds {\n  _min: number;\n  _max: number;\n  _low: number;\n  _high: number;\n  _maxRange: number;\n  _minRange: number;\n  constructor(initialLow: number, initialHigh: number, maxRange: number, minRange: number) {\n    this._min = initialLow;\n    this._max = initialHigh;\n    this._low = this._min;\n    this._high = this._max;\n    this._maxRange = maxRange;\n    this._minRange = minRange;\n  }\n\n  get low(): number {\n    return this._low;\n  }\n\n  get high(): number {\n    return this._high;\n  }\n\n  get min(): number {\n    return this._min;\n  }\n\n  get max(): number {\n    return this._max;\n  }\n\n  get range(): number {\n    return this._high - this._low;\n  }\n\n  _reassertBounds(): void {\n    let needsAdjustment = true;\n    while (needsAdjustment) {\n      needsAdjustment = false;\n      if (this.range < this._minRange) {\n        needsAdjustment = true;\n        const delta = (this._minRange - this.range) / 2;\n        this._high += delta;\n        this._low -= delta;\n      }\n\n      if (this._low < this._min) {\n        needsAdjustment = true;\n        this._low = this._min;\n      }\n\n      if (this._high > this._max) {\n        needsAdjustment = true;\n        this._high = this._max;\n      }\n    }\n  }\n\n  /**\n   * zoom out |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomOut(amount: number, position: number): void {\n    const range = this._high - this._low;\n    const growSize = range * Math.pow(1.1, amount) - range;\n    const lowEnd = growSize * position;\n    const highEnd = growSize - lowEnd;\n    this._low -= lowEnd;\n    this._high += highEnd;\n    this._reassertBounds();\n  }\n\n  /**\n   * zoom in |amount| ticks at position [0, 1] along the current range of the timeline.\n   */\n  zoomIn(amount: number, position: number): void {\n    const range = this._high - this._low;\n    if (this.range <= this._minRange) {\n      return;\n    }\n\n    const shrinkSize = range - range / Math.pow(1.1, amount);\n    const lowEnd = shrinkSize * position;\n    const highEnd = shrinkSize - lowEnd;\n    this._low += lowEnd;\n    this._high -= highEnd;\n    this._reassertBounds();\n  }\n\n  /**\n   * Add Xms to the max value, and scroll the timeline forward if the end is in sight.\n   */\n  addMax(amount: number): void {\n    const range = this._high - this._low;\n    const isAtHighEnd = this._high === this._max;\n    const isZoomedOut = this._low === this._min || range >= this._maxRange;\n\n    this._max += amount;\n    if (isAtHighEnd && isZoomedOut) {\n      this._high = this._max;\n    }\n    this._reassertBounds();\n  }\n\n  /**\n   * Attempt to push the maximum time up to |time| ms.\n   */\n  pushMaxAtLeastTo(time: number): boolean {\n    if (this._max < time) {\n      this.addMax(time - this._max);\n      return true;\n    }\n    return false;\n  }\n}\n"]}