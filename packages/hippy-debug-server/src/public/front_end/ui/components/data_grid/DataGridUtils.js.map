{"version":3,"file":"DataGridUtils.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/data_grid/DataGridUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as DataGridRenderers from './DataGridRenderers.js';\n\n/**\n  * A column is an object with the following properties:\n  *\n  * - `id`: a unique ID for that column.\n  * - `title`: the user visible title.\n  * - `visible`: if the column is visible when rendered\n  * - `hideable`: if the user is able to show/hide the column via the context menu.\n  * - `widthWeighting`: a number that denotes the width of the column. This is a proportion\n  *   of the total weighting of all columns (for details see below).\n  * - `sortable`: an optional property to denote if the  column is sortable.\n  *   Note, if you're rendering a data-grid yourself you likely  shouldn't set\n  *   this. It's set by the `data-grid-controller`, which is the component you\n  *   want if your table needs to be sortable.\n*/\nexport interface Column {\n  id: string;\n  title: string;\n  sortable?: boolean;\n  widthWeighting: number;\n  hideable: boolean;\n  visible: boolean;\n}\n\nexport type CellValue = string|number|boolean|null;\n\n/**\n * A cell contains a `columnId`, which is the ID of the column the cell\n * reprsents, and the `value`, which is a string value for that cell.\n *\n * Note that currently cells cannot render complex data (e.g. nested HTML) but\n * in future we may extend the DataGrid to support this.\n */\nexport interface Cell {\n  columnId: string;\n  value: CellValue;\n  title?: string;\n  renderer?: (value: CellValue) => LitHtml.TemplateResult | typeof LitHtml.nothing;\n}\n\nexport interface RowCSSStylesObject {\n  readonly [name: string]: string;\n}\n\nexport type Row = {\n  cells: Cell[],\n  hidden?: boolean,\n  styles?: RowCSSStylesObject,\n};\n\nexport const enum SortDirection {\n  ASC = 'ASC',\n  DESC = 'DESC',\n}\n\nexport interface SortState {\n  columnId: string;\n  direction: SortDirection;\n}\n\nexport type CellPosition = readonly [columnIndex: number, rowIndex: number];\n\nexport function getRowEntryForColumnId(row: Row, id: string): Cell {\n  const rowEntry = row.cells.find(r => r.columnId === id);\n  if (rowEntry === undefined) {\n    throw new Error(`Found a row that was missing an entry for column ${id}.`);\n  }\n\n  return rowEntry;\n}\n\nexport function renderCellValue(cell: Cell): LitHtml.TemplateResult|typeof LitHtml.nothing {\n  if (cell.renderer) {\n    return cell.renderer(cell.value);\n  }\n\n  return DataGridRenderers.primitiveRenderer(cell.value);\n}\n\n\n/**\n * When the user passes in columns we want to know how wide each one should be.\n * We don't work in exact percentages, or pixel values, because it's then\n * unclear what to do in the event that one column is hidden. How do we\n * distribute up the extra space?\n *\n * Instead, each column has a weighting, which is its width proportionate to the\n * total weighting of all columns. For example:\n *\n * -> two columns both with widthWeighting: 1, will be 50% each, because the\n * total weight = 2, and each column is 1\n *\n * -> if you have two columns, the first width a weight of 2, and the second\n * with a weight of 1, the first will take up 66% and the other 33%.\n *\n * This way, when you are calculating the %, it's easy to do because if a\n * particular column becomes hidden, you ignore it / give it a weighting of 0,\n * and the space is evenly distributed amongst the remaining visible columns.\n *\n * @param allColumns\n * @param columnId\n */\nexport function calculateColumnWidthPercentageFromWeighting(allColumns: readonly Column[], columnId: string): number {\n  const totalWeights =\n      allColumns.filter(c => c.visible).reduce((sumOfWeights, col) => sumOfWeights + col.widthWeighting, 0);\n  const matchingColumn = allColumns.find(c => c.id === columnId);\n  if (!matchingColumn) {\n    throw new Error(`Could not find column with ID ${columnId}`);\n  }\n  if (matchingColumn.widthWeighting < 1) {\n    throw new Error(`Error with column ${columnId}: width weightings must be >= 1.`);\n  }\n  if (!matchingColumn.visible) {\n    return 0;\n  }\n\n  return Math.round((matchingColumn.widthWeighting / totalWeights) * 100);\n}\n\nexport interface HandleArrowKeyOptions {\n  key: Platform.KeyboardUtilities.ArrowKey;\n  currentFocusedCell: readonly[number, number];\n  columns: readonly Column[];\n  rows: readonly Row[];\n}\n\nexport function handleArrowKeyNavigation(options: HandleArrowKeyOptions): CellPosition {\n  const {key, currentFocusedCell, columns, rows} = options;\n  const [selectedColIndex, selectedRowIndex] = currentFocusedCell;\n\n  switch (key) {\n    case Platform.KeyboardUtilities.ArrowKey.LEFT: {\n      const firstVisibleColumnIndex = columns.findIndex(c => c.visible);\n      if (selectedColIndex === firstVisibleColumnIndex) {\n        // User is as far left as they can go, so don't move them.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      // Set the next index to first be the column we are already on, and then\n      // iterate back through all columns to our left, breaking the loop if we\n      // find one that's not hidden. If we don't find one, we'll stay where we\n      // are.\n      let nextColIndex = selectedColIndex;\n      for (let i = nextColIndex - 1; i >= 0; i--) {\n        const col = columns[i];\n        if (col.visible) {\n          nextColIndex = i;\n          break;\n        }\n      }\n\n      return [nextColIndex, selectedRowIndex];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.RIGHT: {\n      // Set the next index to first be the column we are already on, and then\n      // iterate through all columns to our right, breaking the loop if we\n      // find one that's not hidden. If we don't find one, we'll stay where we\n      // are.\n      let nextColIndex = selectedColIndex;\n      for (let i = nextColIndex + 1; i < columns.length; i++) {\n        const col = columns[i];\n        if (col.visible) {\n          nextColIndex = i;\n          break;\n        }\n      }\n\n      return [nextColIndex, selectedRowIndex];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.UP: {\n      const columnsSortable = columns.some(col => col.sortable === true);\n      const minRowIndex = columnsSortable ? 0 : 1;\n      if (selectedRowIndex === minRowIndex) {\n        // If any columns are sortable the user can navigate into the column\n        // header row, else they cannot. So if they are on the highest row they\n        // can be, just return the current cell as they cannot move up.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      let rowIndexToMoveTo = selectedRowIndex;\n\n      for (let i = selectedRowIndex - 1; i >= minRowIndex; i--) {\n        // This means we got past all the body rows and therefore the user needs\n        // to go into the column row.\n        if (i === 0) {\n          rowIndexToMoveTo = 0;\n          break;\n        }\n        const matchingRow = rows[i - 1];\n        if (!matchingRow.hidden) {\n          rowIndexToMoveTo = i;\n          break;\n        }\n      }\n\n      return [selectedColIndex, rowIndexToMoveTo];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.DOWN: {\n      if (selectedRowIndex === 0) {\n        // The user is on the column header. So find the first visible body row and take them there!\n        const firstVisibleBodyRowIndex = rows.findIndex(row => !row.hidden);\n        if (firstVisibleBodyRowIndex > -1) {\n          return [selectedColIndex, firstVisibleBodyRowIndex + 1];\n        }\n        // If we didn't find a single visible row, leave the user where they are.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      let rowIndexToMoveTo = selectedRowIndex;\n      // Work down from our starting position to find the next visible row to move to.\n      for (let i = rowIndexToMoveTo + 1; i < rows.length + 1; i++) {\n        const matchingRow = rows[i - 1];\n        if (!matchingRow.hidden) {\n          rowIndexToMoveTo = i;\n          break;\n        }\n      }\n\n      return [selectedColIndex, rowIndexToMoveTo];\n    }\n\n    default:\n      return Platform.assertNever(key, `Unknown arrow key: ${key}`);\n  }\n}\n\nexport const calculateFirstFocusableCell =\n    (options: {columns: readonly Column[], rows: readonly Row[]}): [colIndex: number, rowIndex: number] => {\n      const {columns, rows} = options;\n      const someColumnsSortable = columns.some(col => col.sortable === true);\n      const focusableRowIndex = someColumnsSortable ? 0 : rows.findIndex(row => !row.hidden) + 1;\n      const focusableColIndex = columns.findIndex(col => col.visible);\n\n      return [focusableColIndex, focusableRowIndex];\n    };\n\n\nexport class ContextMenuColumnSortClickEvent extends Event {\n  data: {\n    column: Column,\n  };\n\n  constructor(column: Column) {\n    super('contextmenucolumnsortclick');\n    this.data = {\n      column,\n    };\n  }\n}\n\nexport class ContextMenuHeaderResetClickEvent extends Event {\n  constructor() {\n    super('contextmenuheaderresetclick');\n  }\n}\n"]}