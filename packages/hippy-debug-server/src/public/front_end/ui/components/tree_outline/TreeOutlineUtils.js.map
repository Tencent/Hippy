{"version":3,"file":"TreeOutlineUtils.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/tree_outline/TreeOutlineUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\n\ninterface BaseTreeNode<TreeNodeDataType> {\n  treeNodeData: TreeNodeDataType;\n  renderer?: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => LitHtml.TemplateResult;\n  id?: string;\n}\n\nexport interface TreeNodeWithChildren<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children: () => Promise<TreeNode<TreeNodeDataType>[]>;\n}\n\ninterface LeafNode<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children?: never;\n}\n\nexport type TreeNode<TreeNodeDataType> = TreeNodeWithChildren<TreeNodeDataType>|LeafNode<TreeNodeDataType>;\n\nexport function isExpandableNode<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>):\n    node is TreeNodeWithChildren<TreeNodeDataType> {\n  return 'children' in node;\n}\n\n/**\n * This is a custom lit-html directive that lets us track the DOM nodes that Lit\n * creates and maps them to the tree node that was given to us. This means we\n * can navigate between real DOM node and structural tree node easily in code.\n */\n\nclass TrackDOMNodeToTreeNode extends LitHtml.Directive.Directive {\n  constructor(partInfo: LitHtml.Directive.PartInfo) {\n    super(partInfo);\n\n    if (partInfo.type !== LitHtml.Directive.PartType.ATTRIBUTE) {\n      throw new Error('TrackDOMNodeToTreeNode directive must be used as an attribute.');\n    }\n  }\n\n  update(part: LitHtml.Directive.ElementPart, [weakMap, treeNode]: LitHtml.Directive.DirectiveParameters<this>): void {\n    const elem = part.element;\n    if (!(elem instanceof HTMLLIElement)) {\n      throw new Error('trackTreeNodeToDOMNode must be used on <li> elements.');\n    }\n    weakMap.set(elem, treeNode);\n  }\n\n  /*\n   * Because this directive doesn't render anything, there's no implementation\n   * here for the render method. But we need it to state the params the\n   * directive takes so the update() method's types are correct. Unfortunately\n   * we have to pass any as the generic type because we can't define this class\n   * using a generic - the generic gets lost when wrapped in the directive call\n   * below.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  render(_weakmap: WeakMap<HTMLLIElement, TreeNode<any>>, _treeNode: TreeNode<any>): void {\n  }\n}\n\nexport const trackDOMNodeToTreeNode = LitHtml.Directive.directive(TrackDOMNodeToTreeNode);\n\n\n/**\n * Finds the next sibling of the node's parent, recursing up the tree if\n * required.\n * Given:\n * A\n *   * B\n *     * C\n * D\n * If called on B, this will return D. If called on C, this will also return D.\n */\nconst findNextParentSibling = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  // We go up two parents here because the structure is:\n  // <li treeitem> => <ul group> => <li treeitem>\n  // So if we are on the last treeitem (furthest to the right), we need to find its parent tree item, which is two parents up.\n  const currentDOMNodeParentListItem = currentDOMNode.parentElement?.parentElement;\n\n  if (currentDOMNodeParentListItem && currentDOMNodeParentListItem instanceof HTMLLIElement) {\n    const parentNodeSibling = currentDOMNodeParentListItem.nextElementSibling;\n    // If this parent doesn't have a sibling, recurse up the tree to look for\n    // the nearest parent that does have a sibling.\n    if (parentNodeSibling && parentNodeSibling instanceof HTMLLIElement) {\n      return parentNodeSibling;\n    }\n    return findNextParentSibling(currentDOMNodeParentListItem);\n  }\n  return null;\n};\n\nconst getFirstChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const firstChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:first-child');\n  if (!firstChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n  return firstChild;\n};\n\nconst domNodeIsExpandable = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNode.getAttribute('aria-expanded') !== null;\n};\n\nconst domNodeIsLeafNode = (domNode: HTMLLIElement): boolean => {\n  return !domNodeIsExpandable(domNode);\n};\n\nconst domNodeIsExpanded = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNodeIsExpandable(domNode) && domNode.getAttribute('aria-expanded') === 'true';\n};\n\nconst getDeepLastChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const lastChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:last-child');\n  if (!lastChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n\n  if (domNodeIsExpanded(lastChild)) {\n    return getDeepLastChildOfExpandedTreeNode(lastChild);\n  }\n  return lastChild;\n};\n\nconst getNextSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.nextElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getPreviousSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.previousElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getParentListItemForDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  let parentNode = currentDOMNode.parentElement;\n  if (!parentNode) {\n    return null;\n  }\n  while (parentNode && parentNode.getAttribute('role') !== 'treeitem' &&\n         (parentNode instanceof HTMLLIElement) === false) {\n    parentNode = parentNode.parentElement;\n  }\n  return parentNode as HTMLLIElement;\n};\n\n/**\n * We cache a tree node's children; they are lazily evaluated and if two code\n * paths get the children, we need to make sure they get the same objects.\n *\n * We're OK to use <unknown> here as the weakmap doesn't care and a TreeOutline that\n * adds nodes of type X to the map will always then get children of that type\n * back as that's enforced by the TreeOutline types elsewhere. We can't make\n * this WeakMap easily generic as it's a top level variable.\n */\nconst treeNodeChildrenWeakMap = new WeakMap<TreeNode<unknown>, TreeNode<unknown>[]>();\nexport const getNodeChildren =\n    async<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>): Promise<TreeNode<TreeNodeDataType>[]> => {\n  if (!node.children) {\n    throw new Error('Asked for children of node that does not have any children.');\n  }\n\n  const cachedChildren = treeNodeChildrenWeakMap.get(node as TreeNode<unknown>);\n  if (cachedChildren) {\n    return cachedChildren as unknown as TreeNode<TreeNodeDataType>[];\n  }\n\n  const children = await node.children();\n  treeNodeChildrenWeakMap.set(node as TreeNode<unknown>, children as TreeNode<unknown>[]);\n  return children;\n};\n\n\n/**\n * Searches the tree and returns a path to the given node.\n * e.g. if the tree is:\n * A\n * - B\n *   - C\n * - D\n *   - E\n *   - F\n *\n * And you look for F, you'll get back [A, D, F]\n */\nexport const getPathToTreeNode =\n    async<TreeNodeDataType>(tree: readonly TreeNode<TreeNodeDataType>[], nodeToFind: TreeNode<TreeNodeDataType>):\n        Promise<TreeNode<TreeNodeDataType>[]|null> => {\n          for (const rootNode of tree) {\n            const foundPathOrNull = await getPathToTreeNodeRecursively(rootNode, nodeToFind, [rootNode]);\n            if (foundPathOrNull !== null) {\n              return foundPathOrNull;\n            }\n          }\n          return null;\n        };\n\nconst getPathToTreeNodeRecursively = async<TreeNodeDataType>(\n    currentNode: TreeNode<TreeNodeDataType>, nodeToFind: TreeNode<TreeNodeDataType>,\n    pathToNode: TreeNode<TreeNodeDataType>[]): Promise<TreeNode<TreeNodeDataType>[]|null> => {\n  if (nodeToFind.id && currentNode.id && currentNode.id === nodeToFind.id) {\n    return pathToNode;\n  }\n\n  if (currentNode === nodeToFind) {\n    return pathToNode;\n  }\n  if (currentNode.children) {\n    const children = await getNodeChildren(currentNode);\n    for (const child of children) {\n      const foundPathOrNull = await getPathToTreeNodeRecursively(child, nodeToFind, [...pathToNode, child]);\n      if (foundPathOrNull !== null) {\n        return foundPathOrNull;\n      }\n    }\n  }\n  return null;\n};\n\ninterface KeyboardNavigationOptions<TreeNodeDataType> {\n  currentDOMNode: HTMLLIElement;\n  currentTreeNode: TreeNode<TreeNodeDataType>;\n  direction: Platform.KeyboardUtilities.ArrowKey;\n  setNodeExpandedState: (treeNode: TreeNode<TreeNodeDataType>, expanded: boolean) => void;\n}\n\nexport const findNextNodeForTreeOutlineKeyboardNavigation =\n    <TreeNodeDataType>(options: KeyboardNavigationOptions<TreeNodeDataType>): HTMLLIElement => {\n      const {\n        currentDOMNode,\n        currentTreeNode,\n        direction,\n        setNodeExpandedState,\n      } = options;\n      if (!currentTreeNode) {\n        return currentDOMNode;\n      }\n\n      if (direction === Platform.KeyboardUtilities.ArrowKey.DOWN) {\n        // If the node has expanded children, down takes you into that list.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // If the node has a sibling, we go to that.\n        const currentNodeSibling = getNextSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodeSibling) {\n          return currentNodeSibling;\n        }\n\n        // If the Node's parent has a sibling then we go to that.\n        const parentSibling = findNextParentSibling(currentDOMNode);\n        if (parentSibling) {\n          return parentSibling;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.RIGHT) {\n        if (domNodeIsLeafNode(currentDOMNode)) {\n          // If the node cannot be expanded, we have nothing to do and we leave everything as is.\n          return currentDOMNode;\n        }\n\n        // If the current node is expanded, move and focus into the first child\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // Else, we expand the Node (but leave focus where it is)\n        setNodeExpandedState(currentTreeNode, true);\n        return currentDOMNode;\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.UP) {\n        // First see if there is a previous sibling\n        const currentNodePreviousSibling = getPreviousSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodePreviousSibling) {\n          // We now find the nested node within our previous sibling; if it has\n          // children that are expanded, we want to find the last child and\n          // highlight that, else we'll highlight our sibling directly.\n          if (domNodeIsExpanded(currentNodePreviousSibling)) {\n            return getDeepLastChildOfExpandedTreeNode(currentNodePreviousSibling);\n          }\n          // Otherwise, if we have a previous sibling with no children, focus it.\n          return currentNodePreviousSibling;\n        }\n\n        // Otherwise, let's go to the direct parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.LEFT) {\n        // If the node is expanded, we close it.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          setNodeExpandedState(currentTreeNode, false);\n          return currentDOMNode;\n        }\n\n        // Otherwise, let's go to the parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      }\n\n      // If we got here, there's no other option than to stay put.\n      return currentDOMNode;\n    };\n"]}