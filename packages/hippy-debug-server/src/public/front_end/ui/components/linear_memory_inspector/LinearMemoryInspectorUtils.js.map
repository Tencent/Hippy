{"version":3,"file":"LinearMemoryInspectorUtils.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryInspectorUtils.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,MAAM,CAAC,MAAM,kBAAkB,GAAG,kBAAkB,CAAC;AACrD,MAAM,CAAC,MAAM,cAAc,GAAG,eAAe,CAAC;AAE9C,MAAM,UAAU,WAAW,CAAC,IAAoD;IAC9E,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC7D,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;IACnC,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;AAClD,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,OAAe;IAC3C,OAAO,WAAW,CAAC,EAAC,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;AAC9D,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,OAAe;IAC1C,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACnD,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;IAE/C,IAAI,UAAU,GAAG,SAAS,CAAC;IAC3B,IAAI,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;QACrD,UAAU,GAAG,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;KACpC;SAAM,IAAI,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;QAC5D,UAAU,GAAG,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;KACpC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const HEXADECIMAL_REGEXP = /^0x[a-fA-F0-9]+$/;\nexport const DECIMAL_REGEXP = /^0$|[1-9]\\d*$/;\n\nexport function toHexString(data: {number: number, pad: number, prefix: boolean}): string {\n  const hex = data.number.toString(16).padStart(data.pad, '0');\n  const upperHex = hex.toUpperCase();\n  return data.prefix ? '0x' + upperHex : upperHex;\n}\n\nexport function formatAddress(address: number): string {\n  return toHexString({number: address, pad: 8, prefix: true});\n}\n\nexport function parseAddress(address: string): number|undefined {\n  const hexMatch = address.match(HEXADECIMAL_REGEXP);\n  const decMatch = address.match(DECIMAL_REGEXP);\n\n  let newAddress = undefined;\n  if (hexMatch && hexMatch[0].length === address.length) {\n    newAddress = parseInt(address, 16);\n  } else if (decMatch && decMatch[0].length === address.length) {\n    newAddress = parseInt(address, 10);\n  }\n  return newAddress;\n}\n"]}