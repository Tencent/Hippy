{"version":3,"file":"LinearMemoryViewer.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryViewer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\n\nimport {toHexString} from './LinearMemoryInspectorUtils.js';\n\nconst {render, html} = LitHtml;\n\nexport interface LinearMemoryViewerData {\n  memory: Uint8Array;\n  address: number;\n  memoryOffset: number;\n  focus: boolean;\n}\n\nexport class ByteSelectedEvent extends Event {\n  data: number;\n\n  constructor(address: number) {\n    super('byteselected');\n    this.data = address;\n  }\n}\n\nexport class ResizeEvent extends Event {\n  data: number;\n\n  constructor(numBytesPerPage: number) {\n    super('resize');\n    this.data = numBytesPerPage;\n  }\n}\nexport class LinearMemoryViewer extends HTMLElement {\n  static litTagName = LitHtml.literal`devtools-linear-memory-inspector-viewer`;\n\n  private static readonly BYTE_GROUP_MARGIN = 8;\n  private static readonly BYTE_GROUP_SIZE = 4;\n  private readonly shadow = this.attachShadow({mode: 'open'});\n\n  private readonly resizeObserver = new ResizeObserver(() => this.resize());\n  private isObservingResize = false;\n\n  private memory = new Uint8Array();\n  private address = 0;\n  private memoryOffset = 0;\n\n  private numRows = 1;\n  private numBytesInRow = LinearMemoryViewer.BYTE_GROUP_SIZE;\n\n  private focusOnByte = true;\n\n  private lastKeyUpdateSent: number|undefined = undefined;\n\n  set data(data: LinearMemoryViewerData) {\n    if (data.address < data.memoryOffset || data.address > data.memoryOffset + data.memory.length || data.address < 0) {\n      throw new Error('Address is out of bounds.');\n    }\n\n    if (data.memoryOffset < 0) {\n      throw new Error('Memory offset has to be greater or equal to zero.');\n    }\n\n    this.memory = data.memory;\n    this.address = data.address;\n    this.memoryOffset = data.memoryOffset;\n    this.focusOnByte = data.focus;\n    this.update();\n  }\n\n  connectedCallback(): void {\n    ComponentHelpers.SetCSSProperty.set(this, '--byte-group-margin', `${LinearMemoryViewer.BYTE_GROUP_MARGIN}px`);\n  }\n\n  disconnectedCallback(): void {\n    this.isObservingResize = false;\n    this.resizeObserver.disconnect();\n  }\n\n  private update(): void {\n    this.updateDimensions();\n    this.render();\n    this.focusOnView();\n    this.engageResizeObserver();\n  }\n\n  private focusOnView(): void {\n    if (this.focusOnByte) {\n      const view = this.shadow.querySelector<HTMLDivElement>('.view');\n      if (view) {\n        view.focus();\n      }\n    }\n  }\n\n  private resize(): void {\n    this.update();\n    this.dispatchEvent(new ResizeEvent(this.numBytesInRow * this.numRows));\n  }\n\n  /** Recomputes the number of rows and (byte) columns that fit into the current view. */\n  private updateDimensions(): void {\n    if (this.clientWidth === 0 || this.clientHeight === 0 || !this.shadowRoot) {\n      this.numBytesInRow = LinearMemoryViewer.BYTE_GROUP_SIZE;\n      this.numRows = 1;\n      return;\n    }\n\n    // We initially just plot one row with one byte group (here: byte group size of 4).\n    // Depending on that initially plotted row we can determine how many rows and\n    // bytes per row we can fit:\n    // > 0000000 | b0 b1 b2 b4 | a0 a1 a2 a3       <\n    //             ^-^           ^-^\n    //             byteCellWidth textCellWidth\n    //             ^-------------------------------^\n    //                 widthToFill\n\n    const firstByteCell = this.shadowRoot.querySelector('.byte-cell');\n    const textCell = this.shadowRoot.querySelector('.text-cell');\n    const divider = this.shadowRoot.querySelector('.divider');\n    const rowElement = this.shadowRoot.querySelector('.row');\n\n    if (!firstByteCell || !textCell || !divider || !rowElement) {\n      this.numBytesInRow = LinearMemoryViewer.BYTE_GROUP_SIZE;\n      this.numRows = 1;\n      return;\n    }\n\n    // Calculate the width required for each (unsplittable) group of bytes.\n    const byteCellWidth = firstByteCell.getBoundingClientRect().width;\n    const textCellWidth = textCell.getBoundingClientRect().width;\n    const groupWidth =\n        LinearMemoryViewer.BYTE_GROUP_SIZE * (byteCellWidth + textCellWidth) + LinearMemoryViewer.BYTE_GROUP_MARGIN;\n\n    // Calculate the width to fill.\n    const dividerWidth = divider.getBoundingClientRect().width;\n    // this.clientWidth is rounded, while the other values are not. Subtract one to make\n    // sure that we correctly calculate the widths.\n    const widthToFill = this.clientWidth - 1 -\n        (firstByteCell.getBoundingClientRect().left - this.getBoundingClientRect().left) - dividerWidth;\n    if (widthToFill < groupWidth) {\n      this.numBytesInRow = LinearMemoryViewer.BYTE_GROUP_SIZE;\n      this.numRows = 1;\n      return;\n    }\n\n    this.numBytesInRow = Math.floor(widthToFill / groupWidth) * LinearMemoryViewer.BYTE_GROUP_SIZE;\n    this.numRows = Math.floor(this.clientHeight / rowElement.clientHeight);\n  }\n\n  private engageResizeObserver(): void {\n    if (!this.resizeObserver || this.isObservingResize) {\n      return;\n    }\n\n    this.resizeObserver.observe(this);\n    this.isObservingResize = true;\n  }\n\n  private render(): void {\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    render(html`\n      <style>\n        :host {\n          flex: auto;\n          display: flex;\n          min-height: 20px;\n        }\n\n        .view {\n          overflow: hidden;\n          text-overflow: ellipsis;\n          box-sizing: border-box;\n          background: var(--color-background);\n          outline: none;\n        }\n\n        .row {\n          display: flex;\n          height: 20px;\n          align-items: center;\n        }\n\n        .cell {\n          text-align: center;\n          border: 1px solid transparent;\n          border-radius: 2px;\n        }\n\n        .cell.selected {\n          border-color: var(--color-syntax-3);\n          color: var(--color-syntax-3);\n          background-color: var(--legacy-item-selection-bg-color);\n        }\n\n        .byte-cell {\n          min-width: 21px;\n          color: var(--color-text-primary);\n        }\n\n        .byte-group-margin {\n          margin-left: var(--byte-group-margin);\n        }\n\n        .text-cell {\n          min-width: 14px;\n          color: var(--color-syntax-3);\n        }\n\n        .address {\n          color: var(--color-text-disabled);\n        }\n\n        .address.selected {\n          font-weight: bold;\n          color: var(--color-text-primary);\n        }\n\n        .divider {\n          width: 1px;\n          height: inherit;\n          background-color: var(--color-details-hairline);\n          margin: 0 4px;\n        }\n      </style>\n      <div class=\"view\" tabindex=\"0\" @keydown=${this.onKeyDown}>\n          ${this.renderView()}\n      </div>\n      `, this.shadow, {host: this});\n  }\n\n  private onKeyDown(event: Event): void {\n    const keyboardEvent = event as KeyboardEvent;\n    let newAddress = undefined;\n    if (keyboardEvent.code === 'ArrowUp') {\n      newAddress = this.address - this.numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowDown') {\n      newAddress = this.address + this.numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowLeft') {\n      newAddress = this.address - 1;\n    } else if (keyboardEvent.code === 'ArrowRight') {\n      newAddress = this.address + 1;\n    } else if (keyboardEvent.code === 'PageUp') {\n      newAddress = this.address - this.numBytesInRow * this.numRows;\n    } else if (keyboardEvent.code === 'PageDown') {\n      newAddress = this.address + this.numBytesInRow * this.numRows;\n    }\n\n    if (newAddress !== undefined && newAddress !== this.lastKeyUpdateSent) {\n      this.lastKeyUpdateSent = newAddress;\n      this.dispatchEvent(new ByteSelectedEvent(newAddress));\n    }\n  }\n\n  private renderView(): LitHtml.TemplateResult {\n    const itemTemplates = [];\n    for (let i = 0; i < this.numRows; ++i) {\n      itemTemplates.push(this.renderRow(i));\n    }\n    return html`${itemTemplates}`;\n  }\n\n  private renderRow(row: number): LitHtml.TemplateResult {\n    const {startIndex, endIndex} = {startIndex: row * this.numBytesInRow, endIndex: (row + 1) * this.numBytesInRow};\n\n    const classMap = {\n      address: true,\n      selected: Math.floor((this.address - this.memoryOffset) / this.numBytesInRow) === row,\n    };\n    return html`\n    <div class=\"row\">\n      <span class=\"${LitHtml.Directives.classMap(classMap)}\">${toHexString({number: startIndex + this.memoryOffset, pad: 8, prefix: false})}</span>\n      <span class=\"divider\"></span>\n      ${this.renderByteValues(startIndex, endIndex)}\n      <span class=\"divider\"></span>\n      ${this.renderCharacterValues(startIndex, endIndex)}\n    </div>\n    `;\n  }\n\n  private renderByteValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      // Add margin after each group of bytes of size byteGroupSize.\n      const addMargin = i !== startIndex && (i - startIndex) % LinearMemoryViewer.BYTE_GROUP_SIZE === 0;\n      const selected = i === this.address - this.memoryOffset;\n      const classMap = {\n        'cell': true,\n        'byte-cell': true,\n        'byte-group-margin': addMargin,\n        selected,\n      };\n      const isSelectableCell = i < this.memory.length;\n      const byteValue = isSelectableCell ? html`${toHexString({number: this.memory[i], pad: 2, prefix: false})}` : '';\n      const actualIndex = i + this.memoryOffset;\n      const onSelectedByte = isSelectableCell ? this.onSelectedByte.bind(this, actualIndex) : '';\n      cells.push(html`<span class=\"${LitHtml.Directives.classMap(classMap)}\" @click=${onSelectedByte}>${byteValue}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  private renderCharacterValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      const classMap = {\n        'cell': true,\n        'text-cell': true,\n        selected: this.address - this.memoryOffset === i,\n      };\n      const isSelectableCell = i < this.memory.length;\n      const value = isSelectableCell ? html`${this.toAscii(this.memory[i])}` : '';\n      const onSelectedByte = isSelectableCell ? this.onSelectedByte.bind(this, i + this.memoryOffset) : '';\n      cells.push(html`<span class=\"${LitHtml.Directives.classMap(classMap)}\" @click=${onSelectedByte}>${value}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  private toAscii(byte: number): string {\n    if (byte >= 20 && byte <= 0x7F) {\n      return String.fromCharCode(byte);\n    }\n    return '.';\n  }\n\n  private onSelectedByte(index: number): void {\n    this.dispatchEvent(new ByteSelectedEvent(index));\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-linear-memory-inspector-viewer', LinearMemoryViewer);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface HTMLElementTagNameMap {\n    'devtools-linear-memory-inspector-viewer': LinearMemoryViewer;\n  }\n}\n"]}