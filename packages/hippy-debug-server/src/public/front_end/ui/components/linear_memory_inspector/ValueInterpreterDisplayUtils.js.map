{"version":3,"file":"ValueInterpreterDisplayUtils.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/linear_memory_inspector/ValueInterpreterDisplayUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nconst UIStrings = {\n  /**\n  *@description Text that is shown in the LinearMemoryInspector if a value could not be correctly formatted\n  *             for the requested mode (e.g. we do not floats to be represented as hexadecimal numbers).\n  *             Abbreviation stands for 'not applicable'.\n  */\n  notApplicable: 'N/A',\n};\nconst str_ =\n    i18n.i18n.registerUIStrings('ui/components/linear_memory_inspector/ValueInterpreterDisplayUtils.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport const VALUE_INTEPRETER_MAX_NUM_BYTES = 8;\n\nexport const enum ValueType {\n  Int8 = 'Integer 8-bit',\n  Int16 = 'Integer 16-bit',\n  Int32 = 'Integer 32-bit',\n  Int64 = 'Integer 64-bit',\n  Float32 = 'Float 32-bit',\n  Float64 = 'Float 64-bit',\n  Pointer32 = 'Pointer 32-bit',\n  Pointer64 = 'Pointer 64-bit',\n}\n\nexport const enum Endianness {\n  Little = 'Little Endian',\n  Big = 'Big Endian',\n}\n\nexport const enum ValueTypeMode {\n  Decimal = 'dec',\n  Hexadecimal = 'hex',\n  Octal = 'oct',\n  Scientific = 'sci',\n}\n\nexport function getDefaultValueTypeMapping(): Map<ValueType, ValueTypeMode> {\n  return new Map(DEFAULT_MODE_MAPPING);\n}\n\nconst DEFAULT_MODE_MAPPING = new Map([\n  [ValueType.Int8, ValueTypeMode.Decimal],\n  [ValueType.Int16, ValueTypeMode.Decimal],\n  [ValueType.Int32, ValueTypeMode.Decimal],\n  [ValueType.Int64, ValueTypeMode.Decimal],\n  [ValueType.Float32, ValueTypeMode.Decimal],\n  [ValueType.Float64, ValueTypeMode.Decimal],\n  [ValueType.Pointer32, ValueTypeMode.Hexadecimal],\n  [ValueType.Pointer64, ValueTypeMode.Hexadecimal],\n]);\n\nexport const VALUE_TYPE_MODE_LIST = [\n  ValueTypeMode.Decimal,\n  ValueTypeMode.Hexadecimal,\n  ValueTypeMode.Octal,\n  ValueTypeMode.Scientific,\n];\n\nexport function valueTypeToLocalizedString(valueType: ValueType): string {\n  return i18n.i18n.lockedString(valueType);\n}\n\nexport function isValidMode(type: ValueType, mode: ValueTypeMode): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n      return mode === ValueTypeMode.Decimal || mode === ValueTypeMode.Hexadecimal || mode === ValueTypeMode.Octal;\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return mode === ValueTypeMode.Scientific || mode === ValueTypeMode.Decimal;\n    case ValueType.Pointer32:  // fallthrough\n    case ValueType.Pointer64:\n      return mode === ValueTypeMode.Hexadecimal;\n    default:\n      return Platform.assertNever(type, `Unknown value type: ${type}`);\n  }\n}\n\nexport function isNumber(type: ValueType): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function getPointerAddress(type: ValueType, buffer: ArrayBuffer, endianness: Endianness): number|bigint {\n  if (!isPointer(type)) {\n    console.error(`Requesting address of a non-pointer type: ${type}.\\n`);\n    return NaN;\n  }\n  try {\n    const dataView = new DataView(buffer);\n    const isLittleEndian = endianness === Endianness.Little;\n    return type === ValueType.Pointer32 ? dataView.getUint32(0, isLittleEndian) :\n                                          dataView.getBigUint64(0, isLittleEndian);\n  } catch (e) {\n    return NaN;\n  }\n}\n\nexport function isPointer(type: ValueType): boolean {\n  return type === ValueType.Pointer32 || type === ValueType.Pointer64;\n}\nexport interface FormatData {\n  buffer: ArrayBuffer;\n  type: ValueType;\n  endianness: Endianness;\n  signed: boolean;\n  mode?: ValueTypeMode;\n}\n\nexport function format(formatData: FormatData): string {\n  if (!formatData.mode) {\n    console.error(`No known way of showing value for ${formatData.type}`);\n    return i18nString(UIStrings.notApplicable);\n  }\n  const valueView = new DataView(formatData.buffer);\n  const isLittleEndian = formatData.endianness === Endianness.Little;\n  let value;\n\n  try {\n    switch (formatData.type) {\n      case ValueType.Int8:\n        value = formatData.signed ? valueView.getInt8(0) : valueView.getUint8(0);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int16:\n        value = formatData.signed ? valueView.getInt16(0, isLittleEndian) : valueView.getUint16(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int32:\n        value = formatData.signed ? valueView.getInt32(0, isLittleEndian) : valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int64:\n        value =\n            formatData.signed ? valueView.getBigInt64(0, isLittleEndian) : valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Float32:\n        value = valueView.getFloat32(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.Float64:\n        value = valueView.getFloat64(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.Pointer32:\n        value = valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.Hexadecimal);\n      case ValueType.Pointer64:\n        value = valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.Hexadecimal);\n      default:\n        return Platform.assertNever(formatData.type, `Unknown value type: ${formatData.type}`);\n    }\n  } catch (e) {\n    return i18nString(UIStrings.notApplicable);\n  }\n}\n\nexport function formatFloat(value: number, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toFixed(2).toString();\n    case ValueTypeMode.Scientific:\n      return value.toExponential(2).toString();\n    default:\n      throw new Error(`Unknown mode for floats: ${mode}.`);\n  }\n}\n\nexport function formatInteger(value: number|bigint, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toString();\n    case ValueTypeMode.Hexadecimal:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return '0x' + value.toString(16).toUpperCase();\n    case ValueTypeMode.Octal:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return value.toString(8);\n    default:\n      throw new Error(`Unknown mode for integers: ${mode}.`);\n  }\n}\n"]}