{"version":3,"file":"RenderCoordinator.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/render_coordinator/RenderCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback {\n  (): unknown;\n}\n\ninterface CoordinatorFrame {\n  readers: CoordinatorCallback[];\n  writers: CoordinatorCallback[];\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  constructor() {\n    super('renderqueueempty');\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  constructor() {\n    super('newframe');\n  }\n}\n\ntype RenderCoordinatorResolverCallback = (value: unknown) => void;\ntype RenderCoordinatorRejectorCallback = (error: Error) => void;\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  private readonly logInternal: CoordinatorLogEntry[] = [];\n\n  private readonly pendingWorkFrames: CoordinatorFrame[] = [];\n  private readonly resolvers = new WeakMap<CoordinatorCallback, RenderCoordinatorResolverCallback>();\n  private readonly rejectors = new WeakMap<CoordinatorCallback, RenderCoordinatorRejectorCallback>();\n  private readonly labels = new WeakMap<CoordinatorCallback, string>();\n  private scheduledWorkId = 0;\n\n  done(): Promise<void> {\n    if (this.pendingWorkFrames.length === 0) {\n      this.logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  async read<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_READ);\n  }\n\n  async write<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.enqueueHandler<T>(callback, ACTION.WRITE, labelOrCallback);\n    }\n\n    return this.enqueueHandler<T>(labelOrCallback, ACTION.WRITE, UNNAMED_WRITE);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.logInternal];\n    this.logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.\n   */\n  async scroll<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_SCROLL);\n  }\n\n  private enqueueHandler<T = unknown>(callback: CoordinatorCallback, action: ACTION, label = ''): Promise<T> {\n    this.labels.set(callback, `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`);\n\n    if (this.pendingWorkFrames.length === 0) {\n      this.pendingWorkFrames.push({\n        readers: [],\n        writers: [],\n      });\n    }\n\n    const frame = this.pendingWorkFrames[0];\n    if (!frame) {\n      throw new Error('No frame available');\n    }\n\n    switch (action) {\n      case ACTION.READ:\n        frame.readers.push(callback);\n        break;\n\n      case ACTION.WRITE:\n        frame.writers.push(callback);\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    const resolverPromise = new Promise((resolve, reject) => {\n      this.resolvers.set(callback, resolve);\n      this.rejectors.set(callback, reject);\n    });\n\n    this.scheduleWork();\n    return resolverPromise as Promise<T>;\n  }\n\n  private async handleWork(handler: CoordinatorCallback): Promise<void> {\n    const data = await handler.call(undefined);\n    const resolver = this.resolvers.get(handler);\n    if (!resolver) {\n      throw new Error('Unable to locate resolver');\n    }\n\n    resolver.call(undefined, data);\n    this.resolvers.delete(handler);\n    this.rejectors.delete(handler);\n  }\n\n  private scheduleWork(): void {\n    const hasScheduledWork = this.scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.scheduledWorkId = requestAnimationFrame(async () => {\n      const hasPendingFrames = this.pendingWorkFrames.length > 0;\n      if (!hasPendingFrames) {\n        // No pending frames means all pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.logIfEnabled('[Queue empty]');\n        this.scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.logIfEnabled('[New frame]');\n\n      const frame = this.pendingWorkFrames.shift();\n      if (!frame) {\n        return;\n      }\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      const readers: Promise<unknown>[] = [];\n      for (const reader of frame.readers) {\n        this.logIfEnabled(this.labels.get(reader));\n        readers.push(this.handleWork(reader));\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(readers),\n          new Promise((_, reject) => {\n            setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.rejectAll(frame.readers, err);\n      }\n\n      // Next do all the writers as a block.\n      const writers: Promise<unknown>[] = [];\n      for (const writer of frame.writers) {\n        this.logIfEnabled(this.labels.get(writer));\n        writers.push(this.handleWork(writer));\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(writers),\n          new Promise((_, reject) => {\n            setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.rejectAll(frame.writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.scheduledWorkId = 0;\n      this.scheduleWork();\n    });\n  }\n\n  private rejectAll(handlers: CoordinatorCallback[], error: Error): void {\n    for (const handler of handlers) {\n      const rejector = this.rejectors.get(handler);\n      if (!rejector) {\n        console.warn('Unable to locate rejector');\n        continue;\n      }\n\n      rejector.call(undefined, error);\n      this.resolvers.delete(handler);\n      this.rejectors.delete(handler);\n    }\n  }\n\n  private logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.logInternal.length > this.recordStorageLimit) {\n      this.logInternal.shift();\n    }\n  }\n}\n"]}