{"version":3,"file":"ViewRegistration.js","sourceRoot":"","sources":["../../../../../../front_end/ui/legacy/ViewRegistration.ts"],"names":[],"mappings":"AACA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAC7B,OAAO,KAAK,QAAQ,MAAM,iCAAiC,CAAC;AAC5D,OAAO,KAAK,IAAI,MAAM,yBAAyB,CAAC;AAGhD,OAAO,EAAC,iBAAiB,EAAC,MAAM,kBAAkB,CAAC;AAInD,MAAM,wBAAwB,GAA6B,EAAE,CAAC;AAwG9D,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;AACpC,MAAM,UAAU,qBAAqB,CAAC,YAA8B;IAClE,MAAM,MAAM,GAAG,YAAY,CAAC,EAAE,CAAC;IAC/B,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,sBAAsB,MAAM,GAAG,CAAC,CAAC;IAC/E,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACtB,wBAAwB,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,YAAY,CAAC,CAAC,CAAC;AACrE,CAAC;AAED,MAAM,UAAU,2BAA2B;IACzC,OAAO,wBAAwB,CAAC,MAAM,CAClC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,EAAC,CAAC,CAAC,CAAC;AACtH,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAC,MAAc;IACrD,MAAM,SAAS,GAAG,wBAAwB,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,MAAM,CAAC,CAAC;IACvF,IAAI,SAAS,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;QAC9C,OAAO,KAAK,CAAC;KACd;IACD,wBAAwB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IAC9C,OAAO,IAAI,CAAC;AACd,CAAC;AAGD,MAAM,2BAA2B,GAAwC,EAAE,CAAC;AAE5E,MAAM,mBAAmB,GAAG,IAAI,GAAG,EAAsB,CAAC;AAE1D,MAAM,UAAU,wBAAwB,CAAC,YAA0C;IACjF,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC;IACvC,IAAI,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;QACzC,MAAM,IAAI,KAAK,CAAC,8CAA8C,YAAY,GAAG,CAAC,CAAC;KAChF;IACD,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACtC,2BAA2B,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;AACjD,CAAC;AAED,MAAM,UAAU,8BAA8B;IAC5C,OAAO,2BAA2B,CAAC;AACrC,CAAC;AAED,0BAA0B;AAC1B,MAAM,CAAC,MAAM,0BAA0B,GAAG;IACxC,QAAQ,EAAE,UAAU;IACpB,MAAM,EAAE,QAAQ;IAChB,cAAc,EAAE,gBAAgB;IAChC,KAAK,EAAE,OAAO;IACd,OAAO,EAAE,SAAS;IAClB,QAAQ,EAAE,UAAU;IACpB,OAAO,EAAE,SAAS;CACnB,CAAC","sourcesContent":["\n// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\n\nimport type {ViewLocationResolver} from './View.js';\nimport {PreRegisteredView} from './ViewManager.js';\n\nimport type {Widget} from './Widget.js';\n\nconst registeredViewExtensions: Array<PreRegisteredView> = [];\n\nexport const enum ViewPersistence {\n  CLOSEABLE = 'closeable',\n  PERMANENT = 'permanent',\n  TRANSIENT = 'transient',\n}\n\nexport const enum ViewLocationValues {\n  PANEL = 'panel',\n  SETTINGS_VIEW = 'settings-view',\n  ELEMENTS_SIDEBAR = 'elements-sidebar',\n  SOURCES_SIDEBAR_BOTTOM = 'sources.sidebar-bottom',\n  NAVIGATOR_VIEW = 'navigator-view',\n  DRAWER_VIEW = 'drawer-view',\n  DRAWER_SIDEBAR = 'drawer-sidebar',\n  NETWORK_SIDEBAR = 'network-sidebar',\n  SOURCES_SIDEBAR_TOP = 'sources.sidebar-top',\n  SOURCES_SIDEBAR_TABS = 'sources.sidebar-tabs',\n}\n\nexport interface ViewRegistration {\n  /**\n   * The name of the experiment a view is associated with. Enabling and disabling the declared\n   * experiment will enable and disable the view respectively.\n   */\n  experiment?: Root.Runtime.ExperimentName;\n  /**\n   * A condition represented as a string the view's availability depends on. Conditions come\n   * from the queryParamsObject defined in Runtime and just as the experiment field, they determine the availability\n   * of the view. A condition can be negated by prepending a ‘!’ to the value of the condition\n   * property and in that case the behaviour of the view's availability will be inverted.\n   */\n  condition?: Root.Runtime.ConditionName;\n  /**\n   * The command added to the command menu used to show the view. It usually follows the shape Show <title> as it must\n   * not be localized at declaration since it is localized internally when appending the commands to the command menu.\n   * The existing duplication of the declaration of the title is expected to be removed once the migration to the version\n   * 2 of the localization model has been completed (crbug.com/1136655).\n   */\n  commandPrompt: () => Platform.UIString.LocalizedString;\n\n  /**\n   * A UI string used as the title of the view.\n   */\n  title: () => Platform.UIString.LocalizedString;\n\n  /**\n   * Whether the view is permanently visible or can be opened temporarily.\n   */\n  persistence?: ViewPersistence;\n  /**\n   * Unique identifier of the view.\n   */\n  id: string;\n  /**\n   * An identifier for the location of the view. The location is resolved by\n   * an extension of type '@UI.ViewLocationResolver'.\n   */\n  location?: ViewLocationValues;\n  /**\n   * Whether the view has a toolbar.\n   */\n  hasToolbar?: boolean;\n  /**\n   * Returns an instance of the class that wraps the view.\n   * The common pattern for implementing this function is loading the module with the wrapping 'Widget'\n   * lazily loaded. As an example:\n   *\n   * ```js\n   * let loadedElementsModule;\n   *\n   * async function loadElementsModule() {\n   *\n   *   if (!loadedElementsModule) {\n   *     loadedElementsModule = await import('./elements.js');\n   *   }\n   *   return loadedElementsModule;\n   * }\n   * UI.ViewManager.registerViewExtension({\n   *   <...>\n   *   async loadView() {\n   *      const Elements = await loadElementsModule();\n   *      return Elements.ElementsPanel.ElementsPanel.instance();\n   *   },\n   *   <...>\n   * });\n   * ```\n   */\n  loadView: () => Promise<Widget>;\n  /**\n   * Used to sort the views that appear in a shared location.\n   */\n  order?: number;\n  /**\n   * The names of the settings the registered view performs as UI for.\n   */\n  settings?: Array<string>;\n  /**\n   * Words used to find the view in the Command Menu.\n   */\n  tags?: Array<() => Platform.UIString.LocalizedString>;\n}\n\nconst viewIdSet = new Set<string>();\nexport function registerViewExtension(registration: ViewRegistration): void {\n  const viewId = registration.id;\n  Platform.DCHECK(() => !viewIdSet.has(viewId), `Duplicate view id '${viewId}'`);\n  viewIdSet.add(viewId);\n  registeredViewExtensions.push(new PreRegisteredView(registration));\n}\n\nexport function getRegisteredViewExtensions(): Array<PreRegisteredView> {\n  return registeredViewExtensions.filter(\n      view => Root.Runtime.Runtime.isDescriptorEnabled({experiment: view.experiment(), condition: view.condition()}));\n}\n\nexport function maybeRemoveViewExtension(viewId: string): boolean {\n  const viewIndex = registeredViewExtensions.findIndex(view => view.viewId() === viewId);\n  if (viewIndex < 0 || !viewIdSet.delete(viewId)) {\n    return false;\n  }\n  registeredViewExtensions.splice(viewIndex, 1);\n  return true;\n}\n\n\nconst registeredLocationResolvers: Array<LocationResolverRegistration> = [];\n\nconst viewLocationNameSet = new Set<ViewLocationValues>();\n\nexport function registerLocationResolver(registration: LocationResolverRegistration): void {\n  const locationName = registration.name;\n  if (viewLocationNameSet.has(locationName)) {\n    throw new Error(`Duplicate view location name registration '${locationName}'`);\n  }\n  viewLocationNameSet.add(locationName);\n  registeredLocationResolvers.push(registration);\n}\n\nexport function getRegisteredLocationResolvers(): Array<LocationResolverRegistration> {\n  return registeredLocationResolvers;\n}\n\n// TODO(crbug.com/1181019)\nexport const ViewLocationCategoryValues = {\n  ELEMENTS: 'Elements',\n  DRAWER: 'Drawer',\n  DRAWER_SIDEBAR: 'Drawer sidebar',\n  PANEL: 'Panel',\n  NETWORK: 'Network',\n  SETTINGS: 'Settings',\n  SOURCES: 'Sources',\n};\n\ntype ViewLocationCategory = typeof ViewLocationCategoryValues[keyof typeof ViewLocationCategoryValues];\n\nexport interface LocationResolverRegistration {\n  name: ViewLocationValues;\n  category: ViewLocationCategory;\n  loadResolver: () => Promise<ViewLocationResolver>;\n}\n"]}