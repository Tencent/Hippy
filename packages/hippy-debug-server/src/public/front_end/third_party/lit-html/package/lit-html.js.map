{"version":3,"file":"lit-html.js","sources":["src/lit-html.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\nconst trustedTypes = ((globalThis as unknown) as Partial<Window>).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult<T extends ResultType = ResultType> = {\n  _$litType$: T;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  _$litType$: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  h: TrustedHTML;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = <T extends ResultType>(_$litType$: T) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult<T> => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart$;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart$ = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [TrustedHTML, Array<string | undefined>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string | undefined> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s +\n          marker +\n          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [\n    policy !== undefined\n      ? policy.createHTML(htmlResult)\n      : ((htmlResult as unknown) as TrustedHTML),\n    attrNames,\n  ];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n  /** @internal */\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this.el.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (\n              name.endsWith(boundAttributeSuffix) ||\n              name.startsWith(marker)\n            ) {\n              const realName = attrNames[attrNameIndex++];\n              attrsToRemove.push(name);\n              if (realName !== undefined) {\n                // Lowercase for case-sensitive SVG attributes like viewBox\n                const value = (node as Element).getAttribute(\n                  realName.toLowerCase() + boundAttributeSuffix\n                )!;\n                const statics = value.split(marker);\n                const m = /([.?@])?(.*)/.exec(realName)!;\n                parts.push({\n                  type: ATTRIBUTE_PART,\n                  index: nodeIndex,\n                  name: m[2],\n                  strings: statics,\n                  ctor:\n                    m[1] === '.'\n                      ? PropertyPart\n                      : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                      ? EventPart\n                      : AttributePart,\n                });\n              } else {\n                parts.push({\n                  type: ELEMENT_PART,\n                  index: nodeIndex,\n                });\n              }\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? ((trustedTypes.emptyScript as unknown) as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = (html as unknown) as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnetableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[\n        attributeIndex\n      ] = currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex\n    );\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  /** @internal */\n  readonly ctor: typeof AttributePart;\n  /** @internal */\n  readonly strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `AsyncDirectives` contained\n   * within this part and runs their `disconnected` or `reconnected`, according\n   * to the `isConnected` argument.\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    return wrap(this._$startNode).parentNode!;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = wrap(this._$startNode).nextSibling;\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? wrap(node).nextSibling === null\n        : node === wrap(this._$endNode).previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult\n  ): void {\n    const {values, _$litType$} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof _$litType$ === 'number'\n        ? this._$getTemplate(result as TemplateResult)\n        : (_$litType$.el === undefined &&\n            (_$litType$.el = Template.createElement(\n              _$litType$.h,\n              this.options\n            )),\n          _$litType$);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: TemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/Polymer/lit-html/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n}\n\nexport type {AttributePart};\nclass AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      (wrap(this.element) as Element).setAttribute(this.name, '');\n    } else {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this.element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _Σ object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _Σ = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-rc.2');\n"],"names":["trustedTypes","globalThis","policy","createPolicy","createHTML","s","undefined","marker","Math","random","String","slice","markerMatch","nodeMarker","d","document","createMarker","v","createComment","isPrimitive","value","isArray","Array","isIterable","Symbol","iterator","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","_$litType$","strings","values","html","svg","noChange","for","nothing","templateCache","WeakMap","render","container","options","partOwnerNode","renderBefore","part","_$litPart$","endNode","ChildPart","insertBefore","_$setValue","walker","createTreeWalker","getTemplateHtml","type","l","length","attrNames","rawTextEndRegex","regex","i","attrName","match","attrNameEndIndex","lastIndex","exec","test","RegExp","end","startsWith","push","htmlResult","Template","[object Object]","node","this","nodeIndex","attrNameIndex","partCount","parts","el","createElement","currentNode","content","svgElement","firstChild","remove","append","childNodes","nextNode","nodeType","hasAttributes","attrsToRemove","name","getAttributeNames","endsWith","realName","statics","getAttribute","toLowerCase","split","m","index","ctor","PropertyPart","BooleanAttributePart","EventPart","AttributePart","removeAttribute","tagName","textContent","emptyScript","data","indexOf","_options","innerHTML","resolveDirective","parent","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","_$litDirective$","constructor","_$setDirectiveConnected","_$initialize","_$resolve","TemplateInstance","template","_$template","_$parent","fragment","creationScope","importNode","partIndex","templatePart","nextSibling","ElementPart","_parts","startNode","_$startNode","_$endNode","isConnected","_$setChildPartConnected","parentNode","directiveParent","_$committedValue","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","ref","_insert","previousSibling","createTextNode","result","_$getTemplate","h","_update","instance","_clone","get","set","itemParts","itemPart","item","start","from","n","element","fill","valueIndex","noCommit","change","_commitValue","setAttribute","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","event","call","host","handleEvent","_Σ","Z","U","Y","q","X","tt","it","st","et","ot","nt","rt","lt","ht"],"mappings":"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"}