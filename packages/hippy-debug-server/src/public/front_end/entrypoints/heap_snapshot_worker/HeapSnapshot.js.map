{"version":3,"file":"HeapSnapshot.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\n\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\n/**\n * @interface\n */\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  _snapshot: HeapSnapshot;\n  _edges: Uint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this._snapshot = snapshot;\n    this._edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this._snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this._snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this._snapshot._edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this._edges[this.edgeIndex + this._snapshot._edgeToNodeOffset];\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this._snapshot._edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this._snapshot._edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this._edges[this.edgeIndex + this._snapshot._edgeTypeOffset];\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * @interface\n */\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\n/**\n * @interface\n */\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  _node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this._node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this._node.nodeIndex = index;\n    return this._node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  _edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this._edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this._edge.edgeIndex = index;\n    return this._edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  _retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this._retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this._retainerEdge.setRetainerIndex(index);\n    return this._retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  _sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this._sourceNode = node;\n    this.edge = node._snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this._sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge._snapshot._edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge._snapshot._edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  _snapshot: HeapSnapshot;\n  _retainerIndex!: number;\n  _globalEdgeIndex!: number;\n  _retainingNodeIndex?: number;\n  _edgeInstance?: JSHeapSnapshotEdge|null;\n  _nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this._snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this._snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this._edge().hasStringName();\n  }\n\n  name(): string {\n    return this._edge().name();\n  }\n\n  node(): HeapSnapshotNode {\n    return this._node();\n  }\n\n  nodeIndex(): number {\n    if (typeof this._retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this._retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this._retainerIndex;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this._retainerIndex) {\n      return;\n    }\n\n    if (!this._snapshot._retainingEdges || !this._snapshot._retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this._retainerIndex = retainerIndex;\n    this._globalEdgeIndex = this._snapshot._retainingEdges[retainerIndex];\n    this._retainingNodeIndex = this._snapshot._retainingNodes[retainerIndex];\n    this._edgeInstance = null;\n    this._nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  _node(): HeapSnapshotNode {\n    if (!this._nodeInstance) {\n      this._nodeInstance = this._snapshot.createNode(this._retainingNodeIndex);\n    }\n    return this._nodeInstance;\n  }\n\n  _edge(): JSHeapSnapshotEdge {\n    if (!this._edgeInstance) {\n      this._edgeInstance = this._snapshot.createEdge(this._globalEdgeIndex);\n    }\n    return this._edgeInstance;\n  }\n\n  toString(): string {\n    return this._edge().toString();\n  }\n\n  itemIndex(): number {\n    return this._retainerIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this._globalEdgeIndex);\n  }\n\n  type(): string {\n    return this._edge().type();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  _retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode._snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot._firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot._firstRetainerIndex[retainedNodeOrdinal];\n    this._retainersEnd = snapshot._firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this._retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  _snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this._snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this._snapshot._nodeDistances[this.nodeIndex / this._snapshot._nodeFieldCount];\n  }\n\n  className(): string {\n    throw new Error('Not implemented');\n  }\n\n  classIndex(): number {\n    throw new Error('Not implemented');\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this._snapshot._nodeFieldCount;\n    return this._snapshot._dominatorsTree[this.nodeIndex / this._snapshot._nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this._snapshot._edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    throw new Error('Not implemented');\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this._snapshot._rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this._snapshot.strings[this._name()];\n  }\n\n  retainedSize(): number {\n    return this._snapshot._retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this._snapshot;\n    const ordinal = this.ordinal();\n    return snapshot._firstRetainerIndex[ordinal + 1] - snapshot._firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeSelfSizeOffset];\n  }\n\n  type(): string {\n    return this._snapshot._nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeTraceNodeIdOffset];\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  _name(): number {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeNameOffset];\n  }\n\n  edgeIndexesStart(): number {\n    return this._snapshot._firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this._snapshot._firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this._snapshot._nodeFieldCount;\n  }\n\n  _nextNodeIndex(): number {\n    return this.nodeIndex + this._snapshot._nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeTypeOffset];\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  _nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this._nodesLength = node._snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this._nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node._nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  _itemProvider: HeapSnapshotItemIndexProvider;\n  _indexes: number[]|Uint32Array;\n  _position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this._itemProvider = itemProvider;\n    this._indexes = indexes;\n    this._position = 0;\n  }\n\n  hasNext(): boolean {\n    return this._position < this._indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this._indexes[this._position];\n    return this._itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this._position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  _iterator: HeapSnapshotItemIterator;\n  _filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this._iterator = iterator;\n    this._filter = filter;\n    this._skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this._iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this._iterator.item();\n  }\n\n  next(): void {\n    this._iterator.next();\n    this._skipFilteredItems();\n  }\n\n  _skipFilteredItems(): void {\n    while (this._iterator.hasNext() && this._filter && !this._filter(this._iterator.item())) {\n      this._iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  _dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this._dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this._sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this._sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this._dispatcher) {\n      this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  _sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this._dispatcher) {\n      this._dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\nexport class HeapSnapshotProblemReport {\n  _errors: string[];\n  constructor(title: string) {\n    this._errors = [title];\n  }\n\n  addError(error: string): void {\n    if (this._errors.length > 100) {\n      return;\n    }\n    this._errors.push(error);\n  }\n\n  toString(): string {\n    return this._errors.join('\\n  ');\n  }\n}\nexport interface Profile {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  root_index: number;\n  nodes: Uint32Array;\n  edges: Uint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  trace_function_infos: Uint32Array;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  trace_tree: Object;\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  Unknown = 0,\n  Attached = 1,\n  Detached = 2,\n}\n\nexport abstract class HeapSnapshot {\n  nodes: Uint32Array;\n  containmentEdges: Uint32Array;\n  _metaNode: HeapSnapshotMetainfo;\n  _rawSamples: number[];\n  _samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null;\n  strings: string[];\n  _locations: number[];\n  _progress: HeapSnapshotProgress;\n  _noDistance: number;\n  _rootNodeIndex: number;\n  _snapshotDiffs: {\n    [x: string]: {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    },\n  };\n  _aggregatesForDiff!: {\n    [x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n  };\n  _aggregates: {\n    [x: string]: {\n      [x: string]: AggregatedInfo,\n    },\n  };\n  _aggregatesSortedFlags: {\n    [x: string]: boolean,\n  };\n  _profile: Profile;\n  _nodeTypeOffset!: number;\n  _nodeNameOffset!: number;\n  _nodeIdOffset!: number;\n  _nodeSelfSizeOffset!: number;\n  _nodeEdgeCountOffset!: number;\n  _nodeTraceNodeIdOffset!: number;\n  _nodeFieldCount!: number;\n  _nodeTypes!: string[];\n  _nodeArrayType!: number;\n  _nodeHiddenType!: number;\n  _nodeObjectType!: number;\n  _nodeNativeType!: number;\n  _nodeConsStringType!: number;\n  _nodeSlicedStringType!: number;\n  _nodeCodeType!: number;\n  _nodeSyntheticType!: number;\n  _edgeFieldsCount!: number;\n  _edgeTypeOffset!: number;\n  _edgeNameOffset!: number;\n  _edgeToNodeOffset!: number;\n  _edgeTypes!: string[];\n  _edgeElementType!: number;\n  _edgeHiddenType!: number;\n  _edgeInternalType!: number;\n  _edgeShortcutType!: number;\n  _edgeWeakType!: number;\n  _edgeInvisibleType!: number;\n  _locationIndexOffset!: number;\n  _locationScriptIdOffset!: number;\n  _locationLineOffset!: number;\n  _locationColumnOffset!: number;\n  _locationFieldCount!: number;\n  nodeCount!: number;\n  _edgeCount!: number;\n  _retainedSizes!: Float64Array;\n  _firstEdgeIndexes!: Uint32Array;\n  _retainingNodes!: Uint32Array;\n  _retainingEdges!: Uint32Array;\n  _firstRetainerIndex!: Uint32Array;\n  _nodeDistances!: Int32Array;\n  _firstDominatedNodeIndex!: Uint32Array;\n  _dominatedNodes!: Uint32Array;\n  _dominatorsTree!: Uint32Array;\n  _allocationProfile!: AllocationProfile;\n  _nodeDetachednessOffset!: number;\n  _locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  _lazyStringCache!: {\n    [x: string]: string,\n  };\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this._metaNode = profile.snapshot.meta;\n    this._rawSamples = profile.samples;\n    this._samples = null;\n    this.strings = profile.strings;\n    this._locations = profile.locations;\n    this._progress = progress;\n\n    this._noDistance = -5;\n    this._rootNodeIndex = 0;\n    if (profile.snapshot.root_index) {\n      this._rootNodeIndex = profile.snapshot.root_index;\n    }\n\n    this._snapshotDiffs = {};\n\n    this._aggregates = {};\n\n    this._aggregatesSortedFlags = {};\n    this._profile = profile;\n  }\n\n  initialize(): void {\n    const meta = this._metaNode;\n\n    this._nodeTypeOffset = meta.node_fields.indexOf('type');\n    this._nodeNameOffset = meta.node_fields.indexOf('name');\n    this._nodeIdOffset = meta.node_fields.indexOf('id');\n    this._nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this._nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this._nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this._nodeDetachednessOffset = meta.node_fields.indexOf('detachedness');\n    this._nodeFieldCount = meta.node_fields.length;\n\n    this._nodeTypes = meta.node_types[this._nodeTypeOffset];\n    this._nodeArrayType = this._nodeTypes.indexOf('array');\n    this._nodeHiddenType = this._nodeTypes.indexOf('hidden');\n    this._nodeObjectType = this._nodeTypes.indexOf('object');\n    this._nodeNativeType = this._nodeTypes.indexOf('native');\n    this._nodeConsStringType = this._nodeTypes.indexOf('concatenated string');\n    this._nodeSlicedStringType = this._nodeTypes.indexOf('sliced string');\n    this._nodeCodeType = this._nodeTypes.indexOf('code');\n    this._nodeSyntheticType = this._nodeTypes.indexOf('synthetic');\n\n    this._edgeFieldsCount = meta.edge_fields.length;\n    this._edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this._edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this._edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this._edgeTypes = meta.edge_types[this._edgeTypeOffset];\n    this._edgeTypes.push('invisible');\n    this._edgeElementType = this._edgeTypes.indexOf('element');\n    this._edgeHiddenType = this._edgeTypes.indexOf('hidden');\n    this._edgeInternalType = this._edgeTypes.indexOf('internal');\n    this._edgeShortcutType = this._edgeTypes.indexOf('shortcut');\n    this._edgeWeakType = this._edgeTypes.indexOf('weak');\n    this._edgeInvisibleType = this._edgeTypes.indexOf('invisible');\n\n    const locationFields = meta.location_fields || [];\n\n    this._locationIndexOffset = locationFields.indexOf('object_index');\n    this._locationScriptIdOffset = locationFields.indexOf('script_id');\n    this._locationLineOffset = locationFields.indexOf('line');\n    this._locationColumnOffset = locationFields.indexOf('column');\n    this._locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this._nodeFieldCount;\n    this._edgeCount = this.containmentEdges.length / this._edgeFieldsCount;\n\n    this._retainedSizes = new Float64Array(this.nodeCount);\n    this._firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this._retainingNodes = new Uint32Array(this._edgeCount);\n    this._retainingEdges = new Uint32Array(this._edgeCount);\n    this._firstRetainerIndex = new Uint32Array(this.nodeCount + 1);\n    this._nodeDistances = new Int32Array(this.nodeCount);\n    this._firstDominatedNodeIndex = new Uint32Array(this.nodeCount + 1);\n    this._dominatedNodes = new Uint32Array(this.nodeCount - 1);\n\n    this._progress.updateStatus('Building edge indexes');\n    this._buildEdgeIndexes();\n    this._progress.updateStatus('Building retainers');\n    this._buildRetainers();\n    this._progress.updateStatus('Propagating DOM state');\n    this._propagateDOMState();\n    this._progress.updateStatus('Calculating node flags');\n    this.calculateFlags();\n    this._progress.updateStatus('Calculating distances');\n    this.calculateDistances();\n    this._progress.updateStatus('Building postorder index');\n    const result = this._buildPostOrderIndex();\n    // Actually it is array that maps node ordinal number to dominator node ordinal number.\n    this._progress.updateStatus('Building dominator tree');\n    this._dominatorsTree =\n        this._buildDominatorTree(result.postOrderIndex2NodeOrdinal, result.nodeOrdinal2PostOrderIndex);\n    this._progress.updateStatus('Calculating retained sizes');\n    this._calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);\n    this._progress.updateStatus('Building dominated nodes');\n    this._buildDominatedNodes();\n    this._progress.updateStatus('Calculating statistics');\n    this.calculateStatistics();\n    this._progress.updateStatus('Calculating samples');\n    this._buildSamples();\n    this._progress.updateStatus('Building locations');\n    this._buildLocationMap();\n    this._progress.updateStatus('Finished processing.');\n\n    if (this._profile.snapshot.trace_function_count) {\n      this._progress.updateStatus('Building allocation statistics');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this._nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: {[x: number]: {count: number, size: number, ids: number[]}} = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this._allocationProfile = new AllocationProfile(this._profile, liveObjects);\n      this._progress.updateStatus('done');\n    }\n  }\n\n  _buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const nodeFieldCount = this._nodeFieldCount;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeEdgeCountOffset = this._nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes[nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset] * edgeFieldsCount;\n    }\n  }\n\n  _buildRetainers(): void {\n    const retainingNodes = this._retainingNodes;\n    const retainingEdges = this._retainingEdges;\n    // Index of the first retainer in the _retainingNodes and _retainingEdges\n    // arrays. Addressed by retained node index.\n    const firstRetainerIndex = this._firstRetainerIndex;\n\n    const containmentEdges = this.containmentEdges;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeFieldCount = this._nodeFieldCount;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const nodeCount = this.nodeCount;\n\n    for (let toNodeFieldIndex = edgeToNodeOffset, l = containmentEdges.length; toNodeFieldIndex < l;\n         toNodeFieldIndex += edgeFieldsCount) {\n      const toNodeIndex = containmentEdges[toNodeFieldIndex];\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      ++firstRetainerIndex[toNodeIndex / nodeFieldCount];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        if (toNodeIndex % nodeFieldCount) {\n          throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n        }\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeIndex / nodeFieldCount];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  _allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this._rootNodeIndex);\n  }\n\n  get rootNodeIndex(): number {\n    return this._rootNodeIndex;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize();\n  }\n\n  _getDominatedIndex(nodeIndex: number): number {\n    if (nodeIndex % this._nodeFieldCount) {\n      throw new Error('Invalid nodeIndex: ' + nodeIndex);\n    }\n    return this._firstDominatedNodeIndex[nodeIndex / this._nodeFieldCount];\n  }\n\n  _createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const minNodeId = nodeFilter.minNodeId;\n    const maxNodeId = nodeFilter.maxNodeId;\n    const allocationNodeId = nodeFilter.allocationNodeId;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this._createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-ignore key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this._createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-ignore key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp = searchConfig.isRegex ? new RegExp(query) : createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const stringFilter = (searchConfig.isRegex || !searchConfig.caseSensitive) ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    if (!stringIndexes.size) {\n      return [];\n    }\n\n    const filter = this._createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this._nodeNameOffset;\n    const nodeIdOffset = this._nodeIdOffset;\n    const nodeFieldCount = this._nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (stringIndexes.has(nodes[nodeIndex + nodeNameOffset])) {\n        nodeIds.push(nodes[nodeIndex + nodeIdOffset]);\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const filter = this._createFilter(nodeFilter);\n    // @ts-ignore key is added in _createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.aggregates(false, key, filter);\n  }\n\n  _createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  _createAllocationStackFilter(bottomUpAllocationNodeId: number): ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this._allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this._allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: {[x: number]: boolean} = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  aggregates(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const aggregates = this._buildAggregates(filter);\n\n    let aggregatesByClassName;\n    if (key && this._aggregates[key]) {\n      aggregatesByClassName = this._aggregates[key];\n    } else {\n      this._calculateClassesRetainedSize(aggregates.aggregatesByClassIndex, filter);\n      aggregatesByClassName = aggregates.aggregatesByClassName;\n      if (key) {\n        this._aggregates[key] = aggregatesByClassName;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this._aggregatesSortedFlags[key])) {\n      this._sortAggregateIndexes(aggregates.aggregatesByClassName);\n      if (key) {\n        this._aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregatesByClassName as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n    };\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this._allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this._allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this._allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(): {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} {\n    if (this._aggregatesForDiff) {\n      return this._aggregatesForDiff;\n    }\n\n    const aggregatesByClassName = this.aggregates(true, 'allObjects');\n    this._aggregatesForDiff = {};\n\n    const node = this.createNode();\n    for (const className in aggregatesByClassName) {\n      const aggregate = aggregatesByClassName[className];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      this._aggregatesForDiff[className] = {indexes: indexes, ids: ids, selfSizes: selfSizes};\n    }\n    return this._aggregatesForDiff;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateDistances(filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n    const distances = this._nodeDistances;\n    const noDistance = this._noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this._bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this._bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  _bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const nodeFieldCount = this._nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this._edgeWeakType;\n    const noDistance = this._noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  _buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {aggregatesByClassName: {[x: string]: AggregatedInfo}, aggregatesByClassIndex: {[x: number]: AggregatedInfo}} {\n    const aggregates: {[x: number]: AggregatedInfo} = {};\n\n    const aggregatesByClassName: {[x: string]: AggregatedInfo} = {};\n\n    const classIndexes = [];\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeFieldCount = this._nodeFieldCount;\n    const selfSizeOffset = this._nodeSelfSizeOffset;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this._nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes[nodeIndex + selfSizeOffset];\n      if (!selfSize && nodes[nodeIndex + nodeTypeOffset] !== nodeNativeType) {\n        continue;\n      }\n      const classIndex = node.classIndex();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      if (!(classIndex in aggregates)) {\n        const nodeType = node.type();\n        const nameMatters = nodeType === 'object' || nodeType === 'native';\n        const value = {\n          count: 1,\n          distance: distance,\n          self: selfSize,\n          maxRet: 0,\n          type: nodeType,\n          name: nameMatters ? node.name() : null,\n          idxs: [nodeIndex],\n        };\n        aggregates[classIndex] = value;\n        classIndexes.push(classIndex);\n        aggregatesByClassName[node.className()] = value;\n      } else {\n        const clss = aggregates[classIndex];\n        if (!clss) {\n          continue;\n        }\n        clss.distance = Math.min(clss.distance, distance);\n        ++clss.count;\n        clss.self += selfSize;\n        clss.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (let i = 0, l = classIndexes.length; i < l; ++i) {\n      const classIndex = classIndexes[i];\n      const classIndexValues = aggregates[classIndex];\n      if (!classIndexValues) {\n        continue;\n      }\n      classIndexValues.idxs = classIndexValues.idxs.slice();\n    }\n\n    return {aggregatesByClassName: aggregatesByClassName, aggregatesByClassIndex: aggregates};\n  }\n\n  _calculateClassesRetainedSize(\n      aggregates: {[x: number]: AggregatedInfo}, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this._rootNodeIndex;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classes = [];\n\n    const seenClassNameIndexes = new Map<number, boolean>();\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const nodeNativeType = this._nodeNativeType;\n    const dominatedNodes = this._dominatedNodes;\n    const nodes = this.nodes;\n    const firstDominatedNodeIndex = this._firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classIndex = node.classIndex();\n      const seen = Boolean(seenClassNameIndexes.get(classIndex));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) &&\n          (node.selfSize() || nodes[nodeIndex + nodeTypeOffset] === nodeNativeType)) {\n        aggregates[classIndex].maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassNameIndexes.set(classIndex, true);\n          sizes.push(list.length);\n          classes.push(classIndex);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classIndex = (classes.pop() as number);\n        seenClassNameIndexes.set(classIndex, false);\n      }\n    }\n  }\n\n  _sortAggregateIndexes(aggregates: {[x: string]: AggregatedInfo}): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  /**\n   * The function checks is the edge should be considered during building\n   * postorder iterator and dominator tree.\n   */\n  _isEssentialEdge(nodeIndex: number, edgeType: number): boolean {\n    // Shortcuts at the root node have special meaning of marking user global objects.\n    return edgeType !== this._edgeWeakType &&\n        (edgeType !== this._edgeShortcutType || nodeIndex === this._rootNodeIndex);\n  }\n\n  _buildPostOrderIndex(): {postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array} {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeCount = this.nodeCount;\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const stackNodes = new Uint32Array(nodeCount);\n    const stackCurrentEdge = new Uint32Array(nodeCount);\n    const postOrderIndex2NodeOrdinal = new Uint32Array(nodeCount);\n    const nodeOrdinal2PostOrderIndex = new Uint32Array(nodeCount);\n    const visited = new Uint8Array(nodeCount);\n    let postOrderIndex = 0;\n\n    let stackTop = 0;\n    stackNodes[0] = rootNodeOrdinal;\n    stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal];\n    visited[rootNodeOrdinal] = 1;\n\n    let iteration = 0;\n    while (true) {\n      ++iteration;\n      while (stackTop >= 0) {\n        const nodeOrdinal = stackNodes[stackTop];\n        const edgeIndex = stackCurrentEdge[stackTop];\n        const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n\n        if (edgeIndex < edgesEnd) {\n          stackCurrentEdge[stackTop] += edgeFieldsCount;\n          const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n          if (!this._isEssentialEdge(nodeOrdinal * nodeFieldCount, edgeType)) {\n            continue;\n          }\n          const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n          const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n          if (visited[childNodeOrdinal]) {\n            continue;\n          }\n          const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n          const childNodeFlag = !flags || (flags[childNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (nodeOrdinal !== rootNodeOrdinal && childNodeFlag && !nodeFlag) {\n            continue;\n          }\n          ++stackTop;\n          stackNodes[stackTop] = childNodeOrdinal;\n          stackCurrentEdge[stackTop] = firstEdgeIndexes[childNodeOrdinal];\n          visited[childNodeOrdinal] = 1;\n        } else {\n          // Done with all the node children\n          nodeOrdinal2PostOrderIndex[nodeOrdinal] = postOrderIndex;\n          postOrderIndex2NodeOrdinal[postOrderIndex++] = nodeOrdinal;\n          --stackTop;\n        }\n      }\n\n      if (postOrderIndex === nodeCount || iteration > 1) {\n        break;\n      }\n      const errors = new HeapSnapshotProblemReport(`Heap snapshot: ${\n          nodeCount - postOrderIndex} nodes are unreachable from the root. Following nodes have only weak retainers:`);\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      stackTop = 0;\n      stackNodes[0] = rootNodeOrdinal;\n      stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal + 1];  // no need to reiterate its edges\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i] || !this._hasOnlyWeakRetainers(i)) {\n          continue;\n        }\n\n        // Add all nodes that have only weak retainers to traverse their subgraphs.\n        stackNodes[++stackTop] = i;\n        stackCurrentEdge[stackTop] = firstEdgeIndexes[i];\n        visited[i] = 1;\n\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        const retainers = [];\n        for (let it = dumpNode.retainers(); it.hasNext(); it.next()) {\n          retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);\n        }\n        errors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);\n      }\n      console.warn(errors.toString());\n    }\n\n    // If we already processed all orphan nodes that have only weak retainers and still have some orphans...\n    if (postOrderIndex !== nodeCount) {\n      const errors = new HeapSnapshotProblemReport(\n          'Still found ' + (nodeCount - postOrderIndex) + ' unreachable nodes in heap snapshot:');\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i]) {\n          continue;\n        }\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        errors.addError(dumpNode.name() + ' @' + dumpNode.id());\n        // Fix it by giving the node a postorder index anyway.\n        nodeOrdinal2PostOrderIndex[i] = postOrderIndex;\n        postOrderIndex2NodeOrdinal[postOrderIndex++] = i;\n      }\n      nodeOrdinal2PostOrderIndex[rootNodeOrdinal] = postOrderIndex;\n      postOrderIndex2NodeOrdinal[postOrderIndex++] = rootNodeOrdinal;\n      console.warn(errors.toString());\n    }\n\n    return {\n      postOrderIndex2NodeOrdinal: postOrderIndex2NodeOrdinal,\n      nodeOrdinal2PostOrderIndex: nodeOrdinal2PostOrderIndex,\n    };\n  }\n\n  _hasOnlyWeakRetainers(nodeOrdinal: number): boolean {\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeWeakType = this._edgeWeakType;\n    const edgeShortcutType = this._edgeShortcutType;\n    const containmentEdges = this.containmentEdges;\n    const retainingEdges = this._retainingEdges;\n    const beginRetainerIndex = this._firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = this._firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n      if (retainerEdgeType !== edgeWeakType && retainerEdgeType !== edgeShortcutType) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm is based on the article:\n  // K. Cooper, T. Harvey and K. Kennedy \"A Simple, Fast Dominance Algorithm\"\n  // Softw. Pract. Exper. 4 (2001), pp. 1-10.\n  _buildDominatorTree(postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array): Uint32Array {\n    const nodeFieldCount = this._nodeFieldCount;\n    const firstRetainerIndex = this._firstRetainerIndex;\n    const retainingNodes = this._retainingNodes;\n    const retainingEdges = this._retainingEdges;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const rootNodeIndex = this._rootNodeIndex;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const nodesCount = postOrderIndex2NodeOrdinal.length;\n    const rootPostOrderedIndex = nodesCount - 1;\n    const noEntry = nodesCount;\n    const dominators = new Uint32Array(nodesCount);\n    for (let i = 0; i < rootPostOrderedIndex; ++i) {\n      dominators[i] = noEntry;\n    }\n    dominators[rootPostOrderedIndex] = rootPostOrderedIndex;\n\n    // The affected array is used to mark entries which dominators\n    // have to be racalculated because of changes in their retainers.\n    const affected = new Uint8Array(nodesCount);\n    let nodeOrdinal;\n\n    {  // Mark the root direct children as affected.\n      nodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = firstEdgeIndexes[nodeOrdinal]; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (!this._isEssentialEdge(this._rootNodeIndex, edgeType)) {\n          continue;\n        }\n        const childNodeOrdinal = containmentEdges[edgeIndex + edgeToNodeOffset] / nodeFieldCount;\n        affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n      }\n    }\n\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (let postOrderIndex = rootPostOrderedIndex - 1; postOrderIndex >= 0; --postOrderIndex) {\n        if (affected[postOrderIndex] === 0) {\n          continue;\n        }\n        affected[postOrderIndex] = 0;\n        // If dominator of the entry has already been set to root,\n        // then it can't propagate any further.\n        if (dominators[postOrderIndex] === rootPostOrderedIndex) {\n          continue;\n        }\n        nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n        const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n        let newDominatorIndex: number = noEntry;\n        const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n        const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n        let orphanNode = true;\n        for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n          const retainerEdgeIndex = retainingEdges[retainerIndex];\n          const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n          const retainerNodeIndex = retainingNodes[retainerIndex];\n          if (!this._isEssentialEdge(retainerNodeIndex, retainerEdgeType)) {\n            continue;\n          }\n          orphanNode = false;\n          const retainerNodeOrdinal = retainerNodeIndex / nodeFieldCount;\n          const retainerNodeFlag = !flags || (flags[retainerNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (retainerNodeIndex !== rootNodeIndex && nodeFlag && !retainerNodeFlag) {\n            continue;\n          }\n          let retanerPostOrderIndex: number = nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];\n          if (dominators[retanerPostOrderIndex] !== noEntry) {\n            if (newDominatorIndex === noEntry) {\n              newDominatorIndex = retanerPostOrderIndex;\n            } else {\n              while (retanerPostOrderIndex !== newDominatorIndex) {\n                while (retanerPostOrderIndex < newDominatorIndex) {\n                  retanerPostOrderIndex = dominators[retanerPostOrderIndex];\n                }\n                while (newDominatorIndex < retanerPostOrderIndex) {\n                  newDominatorIndex = dominators[newDominatorIndex];\n                }\n              }\n            }\n            // If idom has already reached the root, it doesn't make sense\n            // to check other retainers.\n            if (newDominatorIndex === rootPostOrderedIndex) {\n              break;\n            }\n          }\n        }\n        // Make root dominator of orphans.\n        if (orphanNode) {\n          newDominatorIndex = rootPostOrderedIndex;\n        }\n        if (newDominatorIndex !== noEntry && dominators[postOrderIndex] !== newDominatorIndex) {\n          dominators[postOrderIndex] = newDominatorIndex;\n          changed = true;\n          nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n          const beginEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal] + edgeToNodeOffset;\n          const endEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal + 1];\n          for (let toNodeFieldIndex = beginEdgeToNodeFieldIndex; toNodeFieldIndex < endEdgeToNodeFieldIndex;\n               toNodeFieldIndex += edgeFieldsCount) {\n            const childNodeOrdinal = containmentEdges[toNodeFieldIndex] / nodeFieldCount;\n            affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n          }\n        }\n      }\n    }\n\n    const dominatorsTree = new Uint32Array(nodesCount);\n    for (let postOrderIndex = 0, l = dominators.length; postOrderIndex < l; ++postOrderIndex) {\n      nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      dominatorsTree[nodeOrdinal] = postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];\n    }\n    return dominatorsTree;\n  }\n\n  _calculateRetainedSizes(postOrderIndex2NodeOrdinal: Uint32Array): void {\n    const nodeCount = this.nodeCount;\n    const nodes = this.nodes;\n    const nodeSelfSizeOffset = this._nodeSelfSizeOffset;\n    const nodeFieldCount = this._nodeFieldCount;\n    const dominatorsTree = this._dominatorsTree;\n    const retainedSizes = this._retainedSizes;\n\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      retainedSizes[nodeOrdinal] = nodes[nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset];\n    }\n\n    // Propagate retained sizes for each node excluding root.\n    for (let postOrderIndex = 0; postOrderIndex < nodeCount - 1; ++postOrderIndex) {\n      const nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n  }\n\n  _buildDominatedNodes(): void {\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = this._firstDominatedNodeIndex;\n    // All nodes except the root have dominators.\n    const dominatedNodes = this._dominatedNodes;\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    const nodeFieldCount = this._nodeFieldCount;\n    const dominatorsTree = this._dominatorsTree;\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = this.nodeCount;\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = this.nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[this.nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  _iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this._firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this._firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this._edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges[edgeIndex + this._edgeToNodeOffset];\n      const childNodeOrdinal = childNodeIndex / this._nodeFieldCount;\n      const type = this.containmentEdges[edgeIndex + this._edgeTypeOffset];\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  _addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n    * The phase propagates whether a node is attached or detached through the\n    * graph and adjusts the low-level representation of nodes.\n    *\n    * State propagation:\n    * 1. Any object reachable from an attached object is itself attached.\n    * 2. Any object reachable from a detached object that is not already\n    *    attached is considered detached.\n    *\n    * Representation:\n    * - Name of any detached node is changed from \"<Name>\"\" to\n    *   \"Detached <Name>\".\n    */\n  _propagateDOMState(): void {\n    if (this._nodeDetachednessOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes[nodeIndex + snapshot._nodeNameOffset];\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot._addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes[nodeIndex + snapshot._nodeNameOffset] = newStringIndex;\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot._nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes[nodeIndex + snapshot._nodeTypeOffset] !== snapshot._nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      snapshot.nodes[nodeIndex + snapshot._nodeDetachednessOffset] = newState;\n\n      if (newState === DOMLinkState.Attached) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.Detached) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot._iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType =>\n              ![snapshot._edgeHiddenType, snapshot._edgeInvisibleType, snapshot._edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      const state = this.nodes[nodeOrdinal * this._nodeFieldCount + this._nodeDetachednessOffset];\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.Unknown) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.Attached);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      const nodeState = this.nodes[nodeOrdinal * this._nodeFieldCount + this._nodeDetachednessOffset];\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.Attached) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.Detached);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  _buildSamples(): void {\n    const samples = this._rawSamples;\n    if (!samples || !samples.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this._metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this._metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this._nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this._samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  _buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this._locations;\n\n    for (let i = 0; i < locations.length; i += this._locationFieldCount) {\n      const nodeIndex = locations[i + this._locationIndexOffset];\n      const scriptId = locations[i + this._locationScriptIdOffset];\n      const line = locations[i + this._locationLineOffset];\n      const col = locations[i + this._locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this._locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this._locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this._samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff}):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff} {\n    let snapshotDiff: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff}|{\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    } = this._snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    });\n\n    const aggregates = this.aggregates(true, 'allObjects');\n    for (const className in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[className];\n      const diff = this._calculateDiffForClass(baseAggregate, aggregates[className]);\n      if (diff) {\n        snapshotDiff[className] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const className in aggregates) {\n      if (className in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this._calculateDiffForClass(emptyBaseAggregate, aggregates[className]);\n      if (classDiff) {\n        snapshotDiff[className] = classDiff;\n      }\n    }\n\n    this._snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  _calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff();\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  _nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this._allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  nodeClassName(snapshotObjectId: number): string|null {\n    const node = this._nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return node.className();\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this._allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, className: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this._snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[className];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(className: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[className].idxs);\n  }\n\n  _maxJsNodeId(): number {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this._nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes[nodeIndex];\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this._rootNodeIndex, this.totalSize, this._maxJsNodeId());\n  }\n}\n\nclass HeapSnapshotMetainfo {\n  location_fields: string[] = [];              // eslint-disable-line @typescript-eslint/naming-convention\n  node_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  node_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  edge_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  edge_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_info_fields: string[] = [];   // eslint-disable-line @typescript-eslint/naming-convention\n  trace_node_fields: string[] = [];            // eslint-disable-line @typescript-eslint/naming-convention\n  sample_fields: string[] = [];                // eslint-disable-line @typescript-eslint/naming-convention\n  type_strings: {[key: string]: string} = {};  // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport class HeapSnapshotHeader {\n  title: string;\n  meta: HeapSnapshotMetainfo;\n  node_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  edge_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_count: number;  // eslint-disable-line @typescript-eslint/naming-convention\n  root_index: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  constructor() {\n    // New format.\n    this.title = '';\n    this.meta = new HeapSnapshotMetainfo();\n    this.node_count = 0;\n    this.edge_count = 0;\n    this.trace_function_count = 0;\n    this.root_index = 0;\n  }\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  _iterator: HeapSnapshotItemIterator;\n  _indexProvider: HeapSnapshotItemIndexProvider;\n  _isEmpty: boolean;\n  _iterationOrder: number[]|null;\n  _currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  _sortedPrefixLength: number;\n  _sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this._iterator = iterator;\n    this._indexProvider = indexProvider;\n    this._isEmpty = !iterator.hasNext();\n    this._iterationOrder = null;\n    this._currentComparator = null;\n    this._sortedPrefixLength = 0;\n    this._sortedSuffixLength = 0;\n  }\n\n  _createIterationOrder(): void {\n    if (this._iterationOrder) {\n      return;\n    }\n    this._iterationOrder = [];\n    for (let iterator = this._iterator; iterator.hasNext(); iterator.next()) {\n      this._iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this._isEmpty;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this._createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this._iterationOrder.length) {\n      end = this._iterationOrder.length;\n    }\n    if (this._sortedPrefixLength < end && begin < this._iterationOrder.length - this._sortedSuffixLength &&\n        this._currentComparator) {\n      const currentComparator = this._currentComparator;\n      this.sort(\n          currentComparator, this._sortedPrefixLength, this._iterationOrder.length - 1 - this._sortedSuffixLength,\n          begin, end - 1);\n      if (begin <= this._sortedPrefixLength) {\n        this._sortedPrefixLength = end;\n      }\n      if (end >= this._iterationOrder.length - this._sortedSuffixLength) {\n        this._sortedSuffixLength = this._iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this._iterationOrder[position++];\n      const item = this._indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this._iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this._currentComparator = comparator;\n    this._sortedPrefixLength = 0;\n    this._sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this._iterator.item() as HeapSnapshotEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeFieldName(ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      if (edgeB.name() === '__proto__') {\n        return -1;\n      }\n      if (edgeA.name() === '__proto__') {\n        return 1;\n      }\n      const result = edgeA.hasStringName() === edgeB.hasStringName() ?\n          (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n          (edgeA.hasStringName() ? -1 : 1);\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeFieldName(ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeFieldName(ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    if (fieldName1 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    } else if (fieldName2 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this._iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this._createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this._iterationOrder.length; i++) {\n      node.nodeIndex = this._iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this._iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this._iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this._currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this._buildCompareFunction(currentComparator);\n    for (let i = 0; i < this._iterationOrder.length; i++) {\n      if (compare(this._iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  _buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function sortByNodeField(fieldAccessor: () => any, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this._iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this._iterationOrder, this._buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  _nodeFlags: {\n    // bit flags\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  _lazyStringCache: {};\n  _flags!: Uint32Array;\n  _statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    super(profile, progress);\n    this._nodeFlags = {\n      // bit flags\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n    this._lazyStringCache = {};\n    this.initialize();\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  calculateFlags(): void {\n    this._flags = new Uint32Array(this.nodeCount);\n    this._markDetachedDOMTreeNodes();\n    this._markQueriableHeapObjects();\n    this._markPageOwnedNodes();\n  }\n\n  calculateDistances(): void {\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden()) {\n        return edge.name() !== 'sloppy_function_map' || node.rawName() !== 'system / NativeContext';\n      }\n      if (node.isArray()) {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        if (node.rawName() !== '(map descriptors)') {\n          return true;\n        }\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      return true;\n    }\n    super.calculateDistances(filter);\n  }\n\n  isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    return {map: this._flags, flag: this._nodeFlags.pageObject};\n  }\n\n  _flagsOfNode(node: HeapSnapshotNode): number {\n    return this._flags[node.nodeIndex / this._nodeFieldCount];\n  }\n\n  _markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const flag = this._nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this._flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  _markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to insonsistent state of internal properties of wrappers.\n    const flag = this._nodeFlags.canBeQueried;\n    const hiddenEdgeType = this._edgeHiddenType;\n    const internalEdgeType = this._edgeInternalType;\n    const invisibleEdgeType = this._edgeInvisibleType;\n    const weakEdgeType = this._edgeWeakType;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this._nodeFieldCount;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n\n    const flags = (this._flags as Uint32Array);\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  _markPageOwnedNodes(): void {\n    const edgeShortcutType = this._edgeShortcutType;\n    const edgeElementType = this._edgeElementType;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeWeakType = this._edgeWeakType;\n    const firstEdgeIndexes = this._firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = (this._flags as Uint32Array);\n    const pageObjectFlag = this._nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this._rootNodeIndex / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      const nodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  calculateStatistics(): void {\n    const nodeFieldCount = this._nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this._nodeTypeOffset;\n    const nodeSizeOffset = this._nodeSelfSizeOffset;\n    const nodeNativeType = this._nodeNativeType;\n    const nodeCodeType = this._nodeCodeType;\n    const nodeConsStringType = this._nodeConsStringType;\n    const nodeSlicedStringType = this._nodeSlicedStringType;\n    const distances = this._nodeDistances;\n    let sizeNative = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes[nodeIndex + nodeSizeOffset];\n      const ordinal = nodeIndex / nodeFieldCount;\n      if (distances[ordinal] >= HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || node.type() === 'string') {\n        sizeStrings += nodeSize;\n      } else if (node.name() === 'Array') {\n        sizeJSArrays += this._calculateArraySize(node);\n      }\n    }\n    this._statistics = new HeapSnapshotModel.HeapSnapshotModel.Statistics();\n    this._statistics.total = this.totalSize;\n    this._statistics.v8heap = this.totalSize - sizeNative;\n    this._statistics.native = sizeNative;\n    this._statistics.code = sizeCode;\n    this._statistics.jsArrays = sizeJSArrays;\n    this._statistics.strings = sizeStrings;\n    this._statistics.system = sizeSystem;\n  }\n\n  _calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this._edgeToNodeOffset;\n    const edgeTypeOffset = this._edgeTypeOffset;\n    const edgeNameOffset = this._edgeNameOffset;\n    const edgeFieldsCount = this._edgeFieldsCount;\n    const edgeInternalType = this._edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges[edgeIndex + edgeNameOffset]];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return /** @type {!HeapSnapshotModel.HeapSnapshotModel.Statistics} */ this._statistics as\n        HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  constructor(snapshot: JSHeapSnapshot, nodeIndex?: number) {\n    super(snapshot, nodeIndex);\n  }\n\n  canBeQueried(): boolean {\n    const snapshot = (this._snapshot as JSHeapSnapshot);\n    const flags = snapshot._flagsOfNode(this);\n    return Boolean(flags & snapshot._nodeFlags.canBeQueried);\n  }\n\n  rawName(): string {\n    return super.name();\n  }\n\n  name(): string {\n    const snapshot = this._snapshot;\n    if (this.rawType() === snapshot._nodeConsStringType) {\n      let string: string = snapshot._lazyStringCache[this.nodeIndex];\n      if (typeof string === 'undefined') {\n        string = this._consStringName();\n        snapshot._lazyStringCache[this.nodeIndex] = string;\n      }\n      return string;\n    }\n    return this.rawName();\n  }\n\n  _consStringName(): string {\n    const snapshot = this._snapshot;\n    const consStringType = snapshot._nodeConsStringType;\n    const edgeInternalType = snapshot._edgeInternalType;\n    const edgeFieldsCount = snapshot._edgeFieldsCount;\n    const edgeToNodeOffset = snapshot._edgeToNodeOffset;\n    const edgeTypeOffset = snapshot._edgeTypeOffset;\n    const edgeNameOffset = snapshot._edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot._firstEdgeIndexes;\n    const nodeFieldCount = snapshot._nodeFieldCount;\n    const nodeTypeOffset = snapshot._nodeTypeOffset;\n    const nodeNameOffset = snapshot._nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes[nodeIndex + nodeTypeOffset] !== consStringType) {\n        name += strings[nodes[nodeIndex + nodeNameOffset]];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges[edgeIndex + edgeNameOffset]];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  className(): string {\n    const type = this.type();\n    switch (type) {\n      case 'hidden':\n        return '(system)';\n      case 'object':\n      case 'native':\n        return this.name();\n      case 'code':\n        return '(compiled code)';\n      default:\n        return '(' + type + ')';\n    }\n  }\n\n  classIndex(): number {\n    const snapshot = this._snapshot;\n    const nodes = snapshot.nodes;\n    const type = nodes[this.nodeIndex + snapshot._nodeTypeOffset];\n    if (type === snapshot._nodeObjectType || type === snapshot._nodeNativeType) {\n      return nodes[this.nodeIndex + snapshot._nodeNameOffset];\n    }\n    return -1 - type;\n  }\n\n  id(): number {\n    const snapshot = this._snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot._nodeIdOffset];\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this._snapshot._nodeHiddenType;\n  }\n\n  isArray(): boolean {\n    return this.rawType() === this._snapshot._nodeArrayType;\n  }\n\n  isSynthetic(): boolean {\n    return this.rawType() === this._snapshot._nodeSyntheticType;\n  }\n\n  isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.name() === '(Document DOM trees)';\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this._snapshot as JSHeapSnapshot);\n    const flags = snapshot._flagsOfNode(this);\n    if (flags & snapshot._nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot._nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  constructor(snapshot: JSHeapSnapshot, edgeIndex?: number) {\n    super(snapshot, edgeIndex);\n  }\n\n  clone(): JSHeapSnapshotEdge {\n    const snapshot = (this._snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this._hasStringName();\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    return isNaN(parseInt(this._name(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this._snapshot._edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this._snapshot._edgeHiddenType;\n  }\n\n  isWeak(): boolean {\n    return this.rawType() === this._snapshot._edgeWeakType;\n  }\n\n  isInternal(): boolean {\n    return this.rawType() === this._snapshot._edgeInternalType;\n  }\n\n  isInvisible(): boolean {\n    return this.rawType() === this._snapshot._edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this._snapshot._edgeShortcutType;\n  }\n\n  name(): string {\n    const name = this._name();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  _hasStringName(): boolean {\n    const type = this.rawType();\n    const snapshot = this._snapshot;\n    return type !== snapshot._edgeElementType && type !== snapshot._edgeHiddenType;\n  }\n\n  _name(): string|number {\n    return this._hasStringName() ? this._snapshot.strings[this._nameOrIndex()] : this._nameOrIndex();\n  }\n\n  _nameOrIndex(): number {\n    return this._edges[this.edgeIndex + this._snapshot._edgeNameOffset];\n  }\n\n  rawType(): number {\n    return this._edges[this.edgeIndex + this._snapshot._edgeTypeOffset];\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  constructor(snapshot: JSHeapSnapshot, retainerIndex: number) {\n    super(snapshot, retainerIndex);\n  }\n\n  clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this._snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this._edge().isHidden();\n  }\n\n  isInternal(): boolean {\n    return this._edge().isInternal();\n  }\n\n  isInvisible(): boolean {\n    return this._edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this._edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this._edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string|null;\n  idxs: number[];\n}\n"]}