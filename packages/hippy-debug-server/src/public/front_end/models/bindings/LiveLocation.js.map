{"version":3,"file":"LiveLocation.js","sourceRoot":"","sources":["../../../../../../front_end/models/bindings/LiveLocation.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAa7B,MAAM,OAAO,oBAAoB;IAC/B,eAAe,CAA+C;IAC9D,aAAa,CAAmB;IAChC,cAAc,CAAqB;IAEnC,YAAY,cAAqD,EAAE,YAA8B;QAC/F,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE9B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,MAAM;QACV,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACzB,OAAO;SACR;QACD,mEAAmE;QACnE,iEAAiE;QACjE,+DAA+D;QAC/D,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;SACrD;aAAM;YACL,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YACjD,MAAM,IAAI,CAAC,cAAc,CAAC;YAC1B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;SAC5B;IACH,CAAC;IAED,KAAK,CAAC,UAAU;QACd,MAAM,iBAAiB,CAAC;IAC1B,CAAC;IAED,OAAO;QACL,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACjC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;IAC9B,CAAC;IAED,KAAK,CAAC,cAAc;QAClB,MAAM,iBAAiB,CAAC;IAC1B,CAAC;CACF;AAED,MAAM,OAAO,gBAAgB;IAC3B,UAAU,CAAoB;IAE9B;QACE,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;IAC9B,CAAC;IAED,IAAI,CAAC,QAAsB;QACzB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAED,OAAO,CAAC,QAAsB;QAC5B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;IAED,UAAU;QACR,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;YACtC,QAAQ,CAAC,OAAO,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable rulesdir/no_underscored_properties */\n\nimport type * as Workspace from '../workspace/workspace.js'; // eslint-disable-line no-unused-vars\n\nexport interface LiveLocation {\n  update(): Promise<void>;\n  uiLocation(): Promise<Workspace.UISourceCode.UILocation|null>;\n  dispose(): void;\n  isIgnoreListed(): Promise<boolean>;\n}\n\nexport class LiveLocationWithPool implements LiveLocation {\n  _updateDelegate: ((arg0: LiveLocation) => Promise<void>)|null;\n  _locationPool: LiveLocationPool;\n  _updatePromise: Promise<void>|null;\n\n  constructor(updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    this._updateDelegate = updateDelegate;\n    this._locationPool = locationPool;\n    this._locationPool._add(this);\n\n    this._updatePromise = null;\n  }\n\n  async update(): Promise<void> {\n    if (!this._updateDelegate) {\n      return;\n    }\n    // The following is a basic scheduling algorithm, guaranteeing that\n    // {_updateDelegate} is always run atomically. That is, we always\n    // wait for an update to finish before we trigger the next run.\n    if (this._updatePromise) {\n      await this._updatePromise.then(() => this.update());\n    } else {\n      this._updatePromise = this._updateDelegate(this);\n      await this._updatePromise;\n      this._updatePromise = null;\n    }\n  }\n\n  async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    throw 'Not implemented';\n  }\n\n  dispose(): void {\n    this._locationPool._delete(this);\n    this._updateDelegate = null;\n  }\n\n  async isIgnoreListed(): Promise<boolean> {\n    throw 'Not implemented';\n  }\n}\n\nexport class LiveLocationPool {\n  _locations: Set<LiveLocation>;\n\n  constructor() {\n    this._locations = new Set();\n  }\n\n  _add(location: LiveLocation): void {\n    this._locations.add(location);\n  }\n\n  _delete(location: LiveLocation): void {\n    this._locations.delete(location);\n  }\n\n  disposeAll(): void {\n    for (const location of this._locations) {\n      location.dispose();\n    }\n  }\n}\n"]}