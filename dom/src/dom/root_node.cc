/*
 * Tencent is pleased to support the open source community by making
 * Hippy available.
 *
 * Copyright (C) 2022 THL A29 Limited, a Tencent company.
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "dom/root_node.h"

#include <stack>

#include "dom/animation/animation_manager.h"
#include "dom/render_manager.h"
#include "footstone/deserializer.h"
#include "footstone/hippy_value.h"

namespace hippy {
inline namespace dom {

constexpr char kDomCreated[] = "DomCreated";
constexpr char kDomUpdated[] = "DomUpdated";
constexpr char kDomDeleted[] = "DomDeleted";
constexpr char kDomTreeCreated[] = "DomTreeCreated";
constexpr char kDomTreeUpdated[] = "DomTreeUpdated";
constexpr char kDomTreeDeleted[] = "DomTreeDeleted";

using Deserializer = footstone::value::Deserializer;
using Serializer = footstone::value::Serializer;
using HippyValueArrayType = footstone::value::HippyValue::HippyValueArrayType;
using Task = footstone::Task;

footstone::utils::PersistentObjectMap<uint32_t, std::shared_ptr<RootNode>> RootNode::persistent_map_;

// In Hippy Vue, there are some special cases where there are multiple update instructions for the same node. This can
// cause issues with the diff algorithm and lead to incorrect results.
//  Example:
//
//  Dom Node:
//  |------|--------------------------------------|
//  |  id  |  style: {text: "a", color: "red"}    |
//  |  1   |  diff: {}                            |
//  |------|--------------------------------------|
//
//  Previous update algorithm:
//  |------|-----------------------| update instructions: |------|-----------------------| update instructions:        |------|-------------------------------------|
//  |  id  |  style: {text: "a"}   | { text: "b"}         |  id  |  style: {text: "b"}   | { text: "b", fontsize: 12}  |  id  |  style: {text: "b", fontsize: 12}   |
//  |  1   |  diff:  {}            | -------------------> |  1   |  diff:  {text: "b"}   | --------------------------> |  1   |  diff:  {fontsize: "b"}             |
//  |------|-----------------------|                      |------|-----------------------|                             |------|-------------------------------------|
// In the previous diff algorithm, the differences were generated by comparing the DOM styles and update instructions.
// However, in Hippy Vue, two update instructions might be generated within the same batch. This can lead to incorrect diff results.
// The diff should be {text: "b", fontsize: 12}, but the previous diff algorithm cacluate {fontsize: "b"}
//
// To address this issue, the new update algorithm is as follows:
// 1. When a node's style needs to be updated for the first time, we save the current style.
// 2. Subsequent update differences are generated by comparing the saved styles with the update instructions.
// 3. At the end of the batch, we clear the saved styles.
bool DomNodeStyleDiffer::Calculate(const std::shared_ptr<hippy::dom::RootNode>& root_node,
                                   const std::shared_ptr<DomInfo>& dom_info, hippy::dom::DiffValue& style_diff,
                                   hippy::dom::DiffValue& ext_style_diff) {
  if (!root_node) return false;
  if (dom_info == nullptr || dom_info->dom_node == nullptr) return false;

  auto dom_node = root_node->GetNode(dom_info->dom_node->GetId());
  if (dom_node == nullptr) return false;
  uint32_t dom_id = dom_node->GetId();

  // 保存 batch 最早的 style 和 ext_style, 该批次中的所有的 diff 都由这个 style 比较产生
  if (node_style_map_.find(dom_id) == node_style_map_.end()) {
    std::unordered_map<std::string, std::shared_ptr<HippyValue>> style;
    std::unordered_map<std::string, std::shared_ptr<HippyValue>> ext_style;
    auto dom_style = dom_node->GetStyleMap();
    for (const auto& pair : *dom_style) {
      style[pair.first] = std::make_shared<HippyValue>(*pair.second);
    }
    node_style_map_.insert({dom_id, style});
    auto dom_ext_style = dom_node->GetExtStyle();
    for (const auto& pair : *dom_ext_style) {
      ext_style[pair.first] = std::make_shared<HippyValue>(*pair.second);
    }
    node_ext_style_map_.insert({dom_id, ext_style});
  }

  auto base_style = node_style_map_.at(dom_id);
  auto base_ext_style = node_ext_style_map_.at(dom_id);
  style_diff = DiffUtils::DiffProps(base_style, *dom_info->dom_node->GetStyleMap(), false);
  ext_style_diff = DiffUtils::DiffProps(base_ext_style, *dom_info->dom_node->GetExtStyle(), false);
  return true;
}

RootNode::RootNode(uint32_t id) : DomNode(id, 0, 0, "", "", nullptr, nullptr, {}) {
  InitLayoutConsts();
  SetRenderInfo({id, 0, 0});
  animation_manager_ = std::make_shared<AnimationManager>();
  interceptors_.push_back(animation_manager_);
  style_differ_ = std::make_unique<DomNodeStyleDiffer>();
}

RootNode::RootNode() : RootNode(0) {}

void RootNode::AddEventListener(const std::string& name, uint64_t listener_id, bool use_capture,
                                const EventCallback& cb) {
  DomNode::AddEventListener(name, listener_id, use_capture, cb);
  AddEvent(GetId(), name);
}

void RootNode::RemoveEventListener(const std::string& name, uint64_t listener_id) {
  DomNode::RemoveEventListener(name, listener_id);
  RemoveEvent(GetId(), name);
}

void RootNode::ReleaseResources() {}

void RootNode::CreateDomNodes(std::vector<std::shared_ptr<DomInfo>>&& nodes, bool needSortByIndex) {
  for (const auto& interceptor : interceptors_) {
    interceptor->OnDomNodeCreate(nodes);
  }
  std::vector<std::shared_ptr<DomNode>> nodes_to_create;
  for (const auto& node_info : nodes) {
    auto& node = node_info->dom_node;
    std::shared_ptr<DomNode> parent_node = GetNode(node->GetPid());
    if (parent_node == nullptr) {
      continue;
    }
    nodes_to_create.push_back(node);
    // 解析布局属性
    node->ParseLayoutStyleInfo();
    parent_node->AddChildByRefInfo(node_info);
    auto event = std::make_shared<DomEvent>(kDomCreated, node, nullptr);
    node->HandleEvent(event);
    OnDomNodeCreated(node);
  }
  for (const auto& node : nodes_to_create) {
    if (needSortByIndex) {
      node->SetRenderInfo({node->GetId(), node->GetPid(), node->GetSelfIndex(), node->GetSelfDepth()});
    } else {
      // 如果不需要对 index 排序，其他场景目前没有用到 depth，避免冗余计算
      node->SetRenderInfo({node->GetId(), node->GetPid(), node->GetSelfIndex(), -1});
    }
  }

  if (needSortByIndex) {
    // 针对反向插入的场景 (比如先查 index = 15的节点，再插入 index = 14，13，12.. 的节点)，先做排序。否则会导致 renderNode 节点位置错乱。详见:
    // https://doc.weixin.qq.com/doc/w3_ANsAsgZ1ACckOPazHXERJqKHOCbP1?scode=AJEAIQdfAAogJJ2RicAMgAvQZ1ACc
    // 排序要保证两个原则：1. 父节点在子节点前；2. 同一父节点的子节点，必须按照 index 从小到大的顺序排序
    // 同一层级，不同父节点的子节点，位置可以交叉，但要保证原则2，即同一父节点子节点 index 是从小到大的顺序
    std::stable_sort(
        nodes_to_create.begin(),
        nodes_to_create.end(),
        [](const std::shared_ptr<hippy::DomNode>& a, const std::shared_ptr<hippy::DomNode>& b)
    {
      auto render_info_a = a->GetRenderInfo();
      auto render_info_b = b->GetRenderInfo();
      if (render_info_a.depth == render_info_b.depth) {
        return render_info_a.index < render_info_b.index;
      }
      return render_info_a.depth < render_info_b.depth;
    });
  }

  auto event = std::make_shared<DomEvent>(kDomTreeCreated, weak_from_this(), nullptr);
  HandleEvent(event);

  if (!nodes_to_create.empty()) {
    dom_operations_.push_back({DomOperation::Op::kOpCreate, nodes_to_create});
  }
}

void RootNode::UpdateDomNodes(std::vector<std::shared_ptr<DomInfo>>&& nodes) {
  for (const auto& interceptor : interceptors_) {
    interceptor->OnDomNodeUpdate(nodes);
  }

  std::vector<std::shared_ptr<DomNode>> nodes_to_update;
  for (const auto& node : nodes) {
    std::shared_ptr<DomNode> dom_node = GetNode(node->dom_node->GetId());
    if (dom_node == nullptr) {
      continue;
    }

    hippy::dom::DiffValue style_diff, ext_style_diff;
    if (!style_differ_->Calculate(std::static_pointer_cast<RootNode>(shared_from_this()), node, style_diff,
                                  ext_style_diff)) {
      continue;
    }

    auto style_update = std::get<0>(style_diff);
    auto ext_update = std::get<0>(ext_style_diff);
    std::shared_ptr<DomValueMap> diff_value = std::make_shared<DomValueMap>();
    if (!style_update->empty()) {
      diff_value->insert(style_update->begin(), style_update->end());
    }
    if (!ext_update->empty()) {
      diff_value->insert(ext_update->begin(), ext_update->end());
    }
    dom_node->SetStyleMap(node->dom_node->GetStyleMap());
    dom_node->SetExtStyleMap(node->dom_node->GetExtStyle());
    dom_node->SetDiffStyle(diff_value);

    auto style_delete = std::get<1>(style_diff);
    auto ext_delete = std::get<1>(ext_style_diff);
    std::shared_ptr<std::vector<std::string>> delete_value = std::make_shared<std::vector<std::string>>();
    if (!style_delete->empty()) {
      delete_value->insert(delete_value->end(), style_delete->begin(), style_delete->end());
      FOOTSTONE_DLOG(INFO) << "UpdateDomNodes : id: " << dom_node->GetId() << ", delete size:" << style_delete->size();
    }
    if (!ext_delete->empty()) {
      delete_value->insert(delete_value->end(), ext_delete->begin(), ext_delete->end());
    }
    dom_node->SetDeleteProps(delete_value);
    if (!style_update->empty() || !style_delete->empty()) {
      dom_node->UpdateLayoutStyleInfo(*style_update, *style_delete);
    }

    if (delete_value->size() != 0 || diff_value->size() != 0) {
      nodes_to_update.push_back(dom_node);
    }

    auto event = std::make_shared<DomEvent>(kDomUpdated, dom_node, nullptr);
    dom_node->HandleEvent(event);
  }

  auto event = std::make_shared<DomEvent>(kDomTreeUpdated, weak_from_this(), nullptr);
  HandleEvent(event);

  if (!nodes_to_update.empty()) {
    dom_operations_.push_back({DomOperation::Op::kOpUpdate, nodes_to_update});
  }
}

void RootNode::MoveDomNodes(std::vector<std::shared_ptr<DomInfo>>&& nodes) {
  for (const auto& interceptor : interceptors_) {
    interceptor->OnDomNodeMove(nodes);
  }
  std::vector<std::shared_ptr<DomNode>> nodes_to_move;
  for (const auto& node_info : nodes) {
    std::shared_ptr<DomNode> parent_node = GetNode(node_info->dom_node->GetPid());
    if (parent_node == nullptr) {
      continue;
    }
    auto node = parent_node->RemoveChildById(node_info->dom_node->GetId());
    if (node == nullptr) {
      continue;
    }
    nodes_to_move.push_back(node);
    parent_node->AddChildByRefInfo(std::make_shared<DomInfo>(node, node_info->ref_info, nullptr));
  }
  for (const auto& node : nodes_to_move) {
    node->SetRenderInfo({node->GetId(), node->GetPid(), node->GetSelfIndex()});
  }
  if (!nodes_to_move.empty()) {
    dom_operations_.push_back({DomOperation::Op::kOpMove, nodes_to_move});
  }
}

void RootNode::DeleteDomNodes(std::vector<std::shared_ptr<DomInfo>>&& nodes) {
  for (const auto& interceptor : interceptors_) {
    interceptor->OnDomNodeDelete(nodes);
  }
  std::vector<std::shared_ptr<DomNode>> nodes_to_delete;
  for (const auto& it : nodes) {
    std::shared_ptr<DomNode> node = GetNode(it->dom_node->GetId());
    if (node == nullptr) {
      continue;
    }
    nodes_to_delete.push_back(node);
    std::shared_ptr<DomNode> parent_node = node->GetParent();
    if (parent_node != nullptr) {
      parent_node->RemoveChildAt(parent_node->IndexOf(node));
    }
    auto event = std::make_shared<DomEvent>(kDomDeleted, node, nullptr);
    node->HandleEvent(event);
    OnDomNodeDeleted(node);
  }

  auto event = std::make_shared<DomEvent>(kDomTreeDeleted, weak_from_this(), nullptr);
  HandleEvent(event);

  if (!nodes_to_delete.empty()) {
    dom_operations_.push_back({DomOperation::Op::kOpDelete, nodes_to_delete});
  }
}

void RootNode::UpdateAnimation(std::vector<std::shared_ptr<DomNode>>&& nodes) {
  std::vector<std::shared_ptr<DomNode>> nodes_to_update;
  for (const auto& it : nodes) {
    auto node = GetNode(it->GetId());
    if (!node) {
      continue;
    }
    node->MarkWillChange(true);
    nodes_to_update.push_back(node);
    node->ParseLayoutStyleInfo();
    auto event = std::make_shared<DomEvent>(kDomUpdated, node, nullptr);
    node->HandleEvent(event);
  }
  auto event = std::make_shared<DomEvent>(kDomTreeUpdated, weak_from_this(), nullptr);
  HandleEvent(event);
  if (!nodes_to_update.empty()) {
    dom_operations_.push_back({DomOperation::Op::kOpUpdate, nodes_to_update});
  }
}

void RootNode::CallFunction(uint32_t id, const std::string& name, const DomArgument& param,
                            const CallFunctionCallback& cb) {
  auto node = GetNode(id);
  if (node) {
    node->CallFunction(name, param, cb);
  }
}

void RootNode::SyncWithRenderManager(const std::shared_ptr<RenderManager>& render_manager) {
  TDF_PERF_DO_STMT_AND_LOG(unsigned long domCnt = dom_operations_.size();, "RootNode::SyncWithRenderManager");
  if (style_differ_ != nullptr) style_differ_->Reset();
  FlushDomOperations(render_manager);
  TDF_PERF_DO_STMT_AND_LOG(unsigned long evCnt = event_operations_.size();
                           , "RootNode::FlushDomOperations Done, dom op count:%lld", domCnt);
  FlushEventOperations(render_manager);
  TDF_PERF_LOG("RootNode::FlushEventOperations Done, event op count:%d", evCnt);
  DoAndFlushLayout(render_manager);
  TDF_PERF_LOG("RootNode::DoAndFlushLayout Done");
  auto dom_manager = dom_manager_.lock();
  if (dom_manager) {
    dom_manager->RecordDomEndTimePoint();
  }
  render_manager->EndBatch(GetWeakSelf());
  TDF_PERF_LOG("RootNode::SyncWithRenderManager End");
}

void RootNode::AddEvent(uint32_t id, const std::string& event_name) {
  event_operations_.push_back({EventOperation::Op::kOpAdd, id, event_name});
}

void RootNode::RemoveEvent(uint32_t id, const std::string& event_name) {
  event_operations_.push_back({EventOperation::Op::kOpRemove, id, event_name});
}

void RootNode::HandleEvent(const std::shared_ptr<DomEvent>& event) {
  FOOTSTONE_DCHECK(event != nullptr);
  if (!event) {
    return;
  }
  auto target = event->GetTarget().lock();
  if (!target) {
    return;
  }
  auto event_name = event->GetType();
  std::stack<std::shared_ptr<DomNode>> capture_list = {};
  // 执行捕获流程，注：target节点event.StopPropagation并不会阻止捕获流程
  if (event->CanCapture()) {
    // 获取捕获列表
    auto parent = target->GetParent();
    while (parent) {
      capture_list.push(parent);
      parent = parent->GetParent();
    }
  }
  auto capture_target_listeners = target->GetEventListener(event_name, true);
  auto bubble_target_listeners = target->GetEventListener(event_name, false);
  // 捕获列表反过来就是冒泡列表，不需要额外遍历生成
  // 执行捕获流程
  std::stack<std::shared_ptr<DomNode>> bubble_list = {};
  while (!capture_list.empty()) {
    auto capture_node = capture_list.top();
    capture_list.pop();
    event->SetCurrentTarget(capture_node);  // 设置当前节点，cb里会用到
    auto listeners = capture_node->GetEventListener(event_name, true);
    for (const auto& listener : listeners) {
      event->SetEventPhase(EventPhase::kCapturePhase);
      listener->cb(event);  // StopPropagation并不会影响同级的回调调用
    }
    if (event->IsPreventCapture()) {  // cb 内部调用了 event.StopPropagation 会阻止捕获
      return;  // 捕获流中StopPropagation不仅会导致捕获流程结束，后面的目标事件和冒泡都会终止
    }
    bubble_list.push(std::move(capture_node));
  }
  // 执行本身节点回调
  event->SetCurrentTarget(event->GetTarget());
  for (const auto& listener : capture_target_listeners) {
    event->SetEventPhase(EventPhase::kAtTarget);
    listener->cb(event);
  }
  if (event->IsPreventCapture()) {
    return;
  }
  for (const auto& listener : bubble_target_listeners) {
    event->SetEventPhase(EventPhase::kAtTarget);
    listener->cb(event);
  }
  if (event->IsPreventBubble()) {
    return;
  }
  // 执行冒泡流程
  while (!bubble_list.empty()) {
    auto bubble_node = bubble_list.top();
    bubble_list.pop();
    event->SetCurrentTarget(bubble_node);
    auto listeners = bubble_node->GetEventListener(event_name, false);
    for (const auto& listener : listeners) {
      event->SetEventPhase(EventPhase::kBubblePhase);
      listener->cb(event);
    }
    if (event->IsPreventBubble()) {
      break;
    }
  }
}

void RootNode::UpdateRenderNode(const std::shared_ptr<DomNode>& node) {
  auto dom_manager = dom_manager_.lock();
  if (!dom_manager) {
    return;
  }
  auto render_manager = dom_manager->GetRenderManager().lock();
  FOOTSTONE_DCHECK(render_manager);
  if (!render_manager) {
    return;
  }
  FOOTSTONE_DCHECK(node);

  // 更新 layout tree
  node->ParseLayoutStyleInfo();

  // 更新属性
  std::vector<std::shared_ptr<DomNode>> nodes;
  nodes.push_back(node);
  render_manager->UpdateRenderNode(GetWeakSelf(), std::move(nodes));
  SyncWithRenderManager(render_manager);
}

uint32_t RootNode::GetChildCount() {
  uint32_t child_count = 0;
  Traverse([&child_count](const std::shared_ptr<DomNode>&) { child_count++; });
  return child_count;
}

std::shared_ptr<DomNode> RootNode::GetNode(uint32_t id) {
  if (id == GetId()) {
    return shared_from_this();
  }
  auto found = nodes_.find(id);
  if (found == nodes_.end()) {
    return nullptr;
  }
  return found->second.lock();
}

std::tuple<float, float> RootNode::GetRootSize() { return GetLayoutSize(); }

void RootNode::SetRootSize(float width, float height) { SetLayoutSize(width, height); }

void RootNode::SetRootOrigin(float x, float y) { SetLayoutOrigin(x, y); }

void RootNode::DoAndFlushLayout(const std::shared_ptr<RenderManager>& render_manager) {
  // Before Layout
  render_manager->BeforeLayout(GetWeakSelf());
  // 触发布局计算
  std::vector<std::shared_ptr<DomNode>> layout_changed_nodes;
  DoLayout(layout_changed_nodes);
  // After Layout
  render_manager->AfterLayout(GetWeakSelf());

  if (!layout_changed_nodes.empty()) {
    render_manager->UpdateLayout(GetWeakSelf(), layout_changed_nodes);
  }
}

void RootNode::FlushDomOperations(const std::shared_ptr<RenderManager>& render_manager) {
  for (auto& dom_operation : dom_operations_) {
    MarkLayoutNodeDirty(dom_operation.nodes);
    switch (dom_operation.op) {
      case DomOperation::Op::kOpCreate:
        render_manager->CreateRenderNode(GetWeakSelf(), std::move(dom_operation.nodes));
        break;
      case DomOperation::Op::kOpUpdate:
        render_manager->UpdateRenderNode(GetWeakSelf(), std::move(dom_operation.nodes));
        break;
      case DomOperation::Op::kOpDelete:
        render_manager->DeleteRenderNode(GetWeakSelf(), std::move(dom_operation.nodes));
        break;
      case DomOperation::Op::kOpMove:
        render_manager->MoveRenderNode(GetWeakSelf(), std::move(dom_operation.nodes));
        break;
      default:
        break;
    }
  }
  dom_operations_.clear();
}

void RootNode::MarkLayoutNodeDirty(const std::vector<std::shared_ptr<DomNode>>& nodes) {
  for (const auto& node : nodes) {
    if (node && node->GetLayoutNode() && !node->GetLayoutNode()->HasParentEngineNode()) {
      auto parent = node->GetParent();
      while (parent) {
        auto layout_node = parent->GetLayoutNode();
        if (layout_node->HasParentEngineNode() && layout_node->HasMeasureFunction()) {
          layout_node->MarkDirty();
          break;
        }
        parent = parent->GetParent();
      }
    }
  }
}

void RootNode::FlushEventOperations(const std::shared_ptr<RenderManager>& render_manager) {
  for (auto& event_operation : event_operations_) {
    const auto& node = GetNode(event_operation.id);
    if (node == nullptr) {
      continue;
    }

    switch (event_operation.op) {
      case EventOperation::Op::kOpAdd:
        render_manager->AddEventListener(GetWeakSelf(), node, event_operation.name);
        break;
      case EventOperation::Op::kOpRemove:
        render_manager->RemoveEventListener(GetWeakSelf(), node, event_operation.name);
        break;
      default:
        break;
    }
  }
  event_operations_.clear();
}

void RootNode::OnDomNodeCreated(const std::shared_ptr<DomNode>& node) {
  nodes_.insert(std::make_pair(node->GetId(), node));
}

void RootNode::OnDomNodeDeleted(const std::shared_ptr<DomNode>& node) {
  if (node) {
    for (const auto& child : node->GetChildren()) {
      if (child) {
        OnDomNodeDeleted(child);
      }
    }
    nodes_.erase(node->GetId());
  }
}

std::weak_ptr<RootNode> RootNode::GetWeakSelf() { return std::static_pointer_cast<RootNode>(shared_from_this()); }

void RootNode::AddInterceptor(const std::shared_ptr<DomActionInterceptor>& interceptor) {
  interceptors_.push_back(interceptor);
}

void RootNode::Traverse(const std::function<void(const std::shared_ptr<DomNode>&)>& on_traverse) {
  std::stack<std::shared_ptr<DomNode>> stack;
  stack.push(shared_from_this());
  while (!stack.empty()) {
    auto top = stack.top();
    stack.pop();
    on_traverse(top);
    auto children = top->GetChildren();
    if (!children.empty()) {
      for (auto it = children.rbegin(); it != children.rend(); ++it) {
        stack.push(*it);
      }
    }
  }
}

}  // namespace dom
}  // namespace hippy
